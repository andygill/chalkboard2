<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>-- {-# OPTIONS_GHC -ddump-simpl-stats #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>-- ChalkBoard Back End
<span class="lineno">    4 </span>-- August 2009
<span class="lineno">    5 </span>-- Kevin Matlage, Andy Gill
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>module Graphics.ChalkBoard.OpenGL.CBBE where
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>-- ChalkBoard or Non-Standard Packages
<span class="lineno">   12 </span>import Graphics.ChalkBoard.CBIR as CBIR
<span class="lineno">   13 </span>import Graphics.ChalkBoard.Types as T (RGB(..),RGBA(..))
<span class="lineno">   14 </span>import Graphics.ChalkBoard.OpenGL.Env
<span class="lineno">   15 </span>import Graphics.ChalkBoard.Options
<span class="lineno">   16 </span>import Graphics.ChalkBoard.Video ( openVideoOutPipe, closeVideoOutPipe, writeNextFrame )
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>import Graphics.UI.GLUT hiding ( GLuint, GLint, GLfloat )
<span class="lineno">   19 </span>import qualified Graphics.UI.GLUT as GLUT 
<span class="lineno">   20 </span>import Graphics.Rendering.OpenGL.Raw.Core31 as GL
<span class="lineno">   21 </span>import Graphics.Rendering.OpenGL.Raw.ARB.Compatibility (gl_LUMINANCE)
<span class="lineno">   22 </span>import qualified Graphics.ChalkBoard.Internals as CBI
<span class="lineno">   23 </span>-- import Graphics.Rendering.OpenGL.GL.Shaders
<span class="lineno">   24 </span>import Codec.Image.DevIL
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>-- Base Packages
<span class="lineno">   27 </span>import Prelude hiding ( lookup )
<span class="lineno">   28 </span>import Control.Concurrent ( forkIO )
<span class="lineno">   29 </span>import Control.Concurrent.MVar ( MVar, newEmptyMVar, tryTakeMVar, takeMVar, putMVar )
<span class="lineno">   30 </span>import Control.Concurrent.Chan
<span class="lineno">   31 </span>import Control.Monad ( when )
<span class="lineno">   32 </span>import Foreign.Ptr ( Ptr, nullPtr, castPtr )
<span class="lineno">   33 </span>import Foreign.C.Types ( CUChar )
<span class="lineno">   34 </span>import Foreign.Marshal.Alloc ( malloc, free )
<span class="lineno">   35 </span>import Foreign.Storable ( peek )
<span class="lineno">   36 </span>import Foreign.Marshal.Array (withArray )
<span class="lineno">   37 </span>import Data.Map hiding ( null )
<span class="lineno">   38 </span>import qualified Data.Map as Map
<span class="lineno">   39 </span>import Data.Maybe ( fromMaybe )
<span class="lineno">   40 </span>import Data.Array.Unboxed as U  
<span class="lineno">   41 </span>import Data.Array.Storable ( withStorableArray, StorableArray )
<span class="lineno">   42 </span>import Data.Array.MArray ( unsafeThaw, newArray_, MArray )
<span class="lineno">   43 </span>import System.Exit ( exitWith, ExitCode(..) )
<span class="lineno">   44 </span>import Data.ByteString (ByteString)
<span class="lineno">   45 </span>import Data.ByteString.Internal (toForeignPtr)
<span class="lineno">   46 </span>import Foreign.ForeignPtr (withForeignPtr)
<span class="lineno">   47 </span>import Foreign.Ptr (plusPtr)
<span class="lineno">   48 </span>import Data.IORef
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>-- Debugging Packages
<span class="lineno">   51 </span>import System.IO ( writeFile, appendFile )
<span class="lineno">   52 </span>import System.Directory ( removeFile, doesFileExist )
<span class="lineno">   53 </span>import Data.Unique
<span class="lineno">   54 </span>--import Data.Time.Clock
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>startRendering :: BufferId -&gt; MVar () -&gt; MVar ([Inst BufferId]) -&gt; [Options] -&gt; IO()
<span class="lineno">   60 </span><span class="decl"><span class="istickedoff">startRendering board booted insts options = do</span>
<span class="lineno">   61 </span><span class="spaces">    </span><span class="istickedoff">-- Take the initial CBIR instructions out of the mvar</span>
<span class="lineno">   62 </span><span class="spaces">    </span><span class="istickedoff">initChanges &lt;- takeMVar insts</span>
<span class="lineno">   63 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno">   64 </span><span class="spaces">    </span><span class="istickedoff">let (x,y) = case initChanges of</span>
<span class="lineno">   65 </span><span class="spaces">               </span><span class="istickedoff">[Allocate viewBoard (w,h) _ _] | <span class="tickonlytrue">viewBoard == board</span> -&gt; (fromIntegral w,fromIntegral h)</span>
<span class="lineno">   66 </span><span class="spaces">               </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;Opps: strange bootstrapping code: &quot; ++ show initChanges</span></span>
<span class="lineno">   67 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   68 </span><span class="spaces">    </span><span class="istickedoff">-- Init GLUT and take/apply any command line arguments that pertain to it or X windows</span>
<span class="lineno">   69 </span><span class="spaces">    </span><span class="istickedoff">getArgsAndInitialize</span>
<span class="lineno">   70 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="istickedoff">-- Select display mode: Double buffered, RGBA,  Alpha components, Depth buffer</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="istickedoff">initialDisplayMode $= [  DoubleBuffered, RGBAMode, WithAlphaComponent, WithDepthBuffer ]</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="istickedoff">-- Get an 800x600 window. Should we change the default?</span>
<span class="lineno">   74 </span><span class="spaces">    </span><span class="istickedoff">initialWindowSize $= Size x y</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">-- Start the window in upper left corner of the screen</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="istickedoff">initialWindowPosition $= Position 0 0</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="istickedoff">-- Open the window</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">createWindow &quot;ChalkBoard&quot;</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="istickedoff">-- Initialize some OpenGL settings and features.</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="istickedoff">initGL</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="istickedoff">-- Also initialize devIL for importing/exporting images</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="istickedoff">ilInit</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">-- Initialize the ChalkBoard Monad state/environment</span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="istickedoff">let state = initCBMState board</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- initCBMEnv options state</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">let debug = (debugFrames env)</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="istickedoff">when (debug) $</span>
<span class="lineno">   91 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">writeFile &quot;./debug.html&quot; &quot;&lt;HTML&gt;\n&lt;TITLE&gt;ChalkBoard Debugging&lt;/TITLE&gt;\n&lt;br&gt;\n&quot;</span></span>
<span class="lineno">   92 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="istickedoff">-- See which version of OpenGL is being used.</span>
<span class="lineno">   94 </span><span class="spaces">    </span><span class="istickedoff">(major,minor) &lt;- get (majorMinor glVersion)</span>
<span class="lineno">   95 </span><span class="spaces">    </span><span class="istickedoff">print $ &quot;OpenGL Version: &quot; ++ (show major) ++ &quot;.&quot; ++ (show minor)</span>
<span class="lineno">   96 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="istickedoff">-- See if one of the fbo extensions is supported</span>
<span class="lineno">   98 </span><span class="spaces">    </span><span class="istickedoff">extensions &lt;- get glExtensions</span>
<span class="lineno">   99 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">fboExtension = (&quot;GL_EXT_framebuffer_object&quot; `elem` extensions || &quot;GL_ARB_framebuffer_object&quot; `elem` extensions)</span></span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  101 </span><span class="spaces">    </span><span class="istickedoff">fboOn &lt;- if <span class="tickonlytrue">(fboSupport env == True &amp;&amp; (major &gt;= 3 || <span class="nottickedoff">fboExtension</span>))</span></span>
<span class="lineno">  102 </span><span class="spaces">                 </span><span class="istickedoff">then do</span>
<span class="lineno">  103 </span><span class="spaces">                     </span><span class="istickedoff">-- Initialize a FBO</span>
<span class="lineno">  104 </span><span class="spaces">                     </span><span class="istickedoff">(fboIdPtr, texIdPtr) &lt;- initFBO -- The returned FBO is still bound as the current framebuffer</span>
<span class="lineno">  105 </span><span class="spaces">                     </span><span class="istickedoff">-- Check if FBOs are supported</span>
<span class="lineno">  106 </span><span class="spaces">                     </span><span class="istickedoff">status &lt;- glCheckFramebufferStatus gl_FRAMEBUFFER</span>
<span class="lineno">  107 </span><span class="spaces">                     </span><span class="istickedoff">print $ &quot;FBO Unsupported?: &quot; ++ (show (status == gl_FRAMEBUFFER_UNSUPPORTED))</span>
<span class="lineno">  108 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  109 </span><span class="spaces">                     </span><span class="istickedoff">-- Depending on whether they're supported or not, determine whether FBOs should be used</span>
<span class="lineno">  110 </span><span class="spaces">                     </span><span class="istickedoff">complete &lt;- if <span class="tickonlytrue">(status == gl_FRAMEBUFFER_COMPLETE)</span></span>
<span class="lineno">  111 </span><span class="spaces">                                     </span><span class="istickedoff">then do</span>
<span class="lineno">  112 </span><span class="spaces">                                         </span><span class="istickedoff">print &quot;FBO Initialization Complete. Using FBOs.&quot;</span>
<span class="lineno">  113 </span><span class="spaces">                                         </span><span class="istickedoff">setFBOPtr env fboIdPtr</span>
<span class="lineno">  114 </span><span class="spaces">                                         </span><span class="istickedoff">return True</span>
<span class="lineno">  115 </span><span class="spaces">                                     </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno">  116 </span><span class="spaces">                                         </span><span class="istickedoff"><span class="nottickedoff">print &quot;FBO Initialization Incomplete. Not Using FBOs.&quot;</span></span>
<span class="lineno">  117 </span><span class="spaces">                                         </span><span class="istickedoff"><span class="nottickedoff">glDeleteFramebuffers 1 fboIdPtr -- Delete the FBO since it isn't being used</span></span>
<span class="lineno">  118 </span><span class="spaces">                                         </span><span class="istickedoff"><span class="nottickedoff">return False</span></span>
<span class="lineno">  119 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  120 </span><span class="spaces">                     </span><span class="istickedoff">-- Delete the texture that was just used to test if FBOs were supported</span>
<span class="lineno">  121 </span><span class="spaces">                     </span><span class="istickedoff">glDeleteTextures 1 texIdPtr</span>
<span class="lineno">  122 </span><span class="spaces">                     </span><span class="istickedoff">-- Return whether the FBO initialization was complete</span>
<span class="lineno">  123 </span><span class="spaces">                     </span><span class="istickedoff">return complete</span>
<span class="lineno">  124 </span><span class="spaces">                 </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno">  125 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">print &quot;FBOs Not Supported. Not Using FBOs.&quot;</span></span>
<span class="lineno">  126 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">return False</span></span>
<span class="lineno">  127 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">-- Start the changeboard timer callback, which will execute all CBIR instructions that are passed in</span>
<span class="lineno">  129 </span><span class="spaces">    </span><span class="istickedoff">changeBoard' (env {fboSupport = fboOn}) (changeBoard (env {fboSupport = fboOn}) insts)  initChanges</span>
<span class="lineno">  130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="istickedoff">-- Register the function called when the window is resized</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="istickedoff">reshapeCallback $= Just resizeScene</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="istickedoff">-- Register the function called when the keyboard is pressed.</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">keyboardMouseCallback $= Just <span class="nottickedoff">(keyPressed (env {fboSupport = fboOn}))</span></span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="istickedoff">-- Start the main GLUT event loop after telling the front end that OpenGL has been booted</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="istickedoff">flush</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="istickedoff">putMVar booted ()</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">mainLoop</span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- Function to initialize the state of the CBBE
<span class="lineno">  144 </span>initCBMState :: BufferId -&gt; CBstate
<span class="lineno">  145 </span><span class="decl"><span class="istickedoff">initCBMState board = CBstate board <span class="nottickedoff">board</span> <span class="nottickedoff">nullPtr</span> (empty) (empty)</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>-- TODO: add option for verboseness
<span class="lineno">  149 </span>--Funciton to initialize the environment of the CBBE monad
<span class="lineno">  150 </span>initCBMEnv :: [Options] -&gt; CBstate -&gt; IO CBenv
<span class="lineno">  151 </span><span class="decl"><span class="istickedoff">initCBMEnv options state = do</span>
<span class="lineno">  152 </span><span class="spaces">        </span><span class="istickedoff">let fboSupport' = not $ NoFBO `elem` options</span>
<span class="lineno">  153 </span><span class="spaces">            </span><span class="istickedoff">debugFrames' = DebugFrames `elem` options</span>
<span class="lineno">  154 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">debugAll' = DebugAll `elem` options</span></span>
<span class="lineno">  155 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">debugBoards' = concat [ids | DebugBoards ids &lt;- options]</span></span>
<span class="lineno">  156 </span><span class="spaces">        </span><span class="istickedoff">v &lt;- newEmptyMVar</span>
<span class="lineno">  157 </span><span class="spaces">        </span><span class="istickedoff">putMVar v state</span>
<span class="lineno">  158 </span><span class="spaces">        </span><span class="istickedoff">ffi &lt;- newIORef empty</span>
<span class="lineno">  159 </span><span class="spaces">        </span><span class="istickedoff">prog &lt;- newIORef <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  160 </span><span class="spaces">        </span><span class="istickedoff">mouseChan &lt;- newIORef <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  161 </span><span class="spaces">        </span><span class="istickedoff">return $ CBenv debugFrames' <span class="nottickedoff">debugAll'</span> <span class="nottickedoff">debugBoards'</span> fboSupport' v ffi <span class="nottickedoff">prog</span> <span class="nottickedoff">mouseChan</span></span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>-- Function to initialize some OpenGL settings and features
<span class="lineno">  168 </span>initGL :: IO ()
<span class="lineno">  169 </span><span class="decl"><span class="istickedoff">initGL = do</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">clearColor $= Color4 1 1 1 1 -- Clear the background color to white</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">-- Not sure if a couple of the things in this block are really needed</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">clearDepth $= 1 -- Enables clearing of the depth buffer</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff">depthFunc  $= Just Less -- Type of depth test</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">shadeModel $= Smooth -- Enables smooth color shading</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">polygonMode $= (Fill,Fill)</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="istickedoff">-- Blending and texture functions that make chalkboard work correctly</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">blend $= Enabled</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">blendFuncSeparate $= ((SrcAlpha, OneMinusSrcAlpha), (One, OneMinusSrcAlpha)) -- Specify color and alpha blend separately</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">texture Texture2D $= Enabled</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">textureFunction $= Replace --Replace destination color and alpha with texture's color and alpha</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="istickedoff">Size width height &lt;- get windowSize -- Get the size of the window</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">resizeScene (Size width height)</span></span> -- Resize the viewport and projection
<span class="lineno">  186 </span>    
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- Will possibly want to change this from using the window w/h to something else (maintain ratio?)
<span class="lineno">  193 </span>-- Reshape callback function to resize the viewing area appropriately when the window is resized.
<span class="lineno">  194 </span>resizeScene :: Size -&gt; IO ()
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">resizeScene (Size w 0) = <span class="nottickedoff">resizeScene (Size w 1)</span> -- prevents divide by zero</span>
<span class="lineno">  196 </span><span class="spaces"></span><span class="istickedoff">resizeScene (Size width height) = do</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">let w = fromIntegral width</span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">h = fromIntegral height</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">viewport   $= (Position 0 0, Size (width*1) (height*1))     -- the whole window is used</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">matrixMode $= Projection</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">loadIdentity</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">ortho2D 0 (w*1) 0 (h*1) -- Will probably want to change this from using the window w/h</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">matrixMode $= Modelview 0</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">flush -- Might not be necessary</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">postRedisplay Nothing</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- Keyboard and Mouse callback function
<span class="lineno">  213 </span>-- Right now just exits the program when the escape key is pressed.
<span class="lineno">  214 </span>keyPressed :: CBenv -&gt; KeyboardMouseCallback
<span class="lineno">  215 </span><span class="decl"><span class="nottickedoff">keyPressed env (Char '\27') Down _ _ = do</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="nottickedoff">debug &lt;- getDebugFrames env</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="nottickedoff">when (debug) $ appendFile &quot;./debug.html&quot; &quot;&lt;/HTML&gt;&quot;</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="nottickedoff">exitWith ExitSuccess -- 27 is ESCAPE</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="nottickedoff">keyPressed env (MouseButton LeftButton) Down _ (Position px py) = do</span>
<span class="lineno">  220 </span><span class="spaces">        </span><span class="nottickedoff">mbChan &lt;- get (callbackChan env)</span>
<span class="lineno">  221 </span><span class="spaces">        </span><span class="nottickedoff">case mbChan of</span>
<span class="lineno">  222 </span><span class="spaces">                </span><span class="nottickedoff">Just chan -&gt; do</span>
<span class="lineno">  223 </span><span class="spaces">                                </span><span class="nottickedoff">Size winW winH &lt;- get windowSize</span>
<span class="lineno">  224 </span><span class="spaces">                                </span><span class="nottickedoff">let (w,h) = (fromIntegral winW, fromIntegral winH)</span>
<span class="lineno">  225 </span><span class="spaces">                                </span><span class="nottickedoff">let (x,y) = (fromIntegral px, fromIntegral py)</span>
<span class="lineno">  226 </span><span class="spaces">                                </span><span class="nottickedoff">--print (x/w-0.5, -(y/h-0.5))</span>
<span class="lineno">  227 </span><span class="spaces">                                </span><span class="nottickedoff">writeChan chan (MouseCallback (x/w-0.5, -(y/h-0.5)))</span>
<span class="lineno">  228 </span><span class="spaces">                </span><span class="nottickedoff">Nothing   -&gt; return ()</span>
<span class="lineno">  229 </span><span class="spaces"></span><span class="nottickedoff">keyPressed env (Char char) Down _ _ = do</span>
<span class="lineno">  230 </span><span class="spaces">        </span><span class="nottickedoff">mbChan &lt;- get (callbackChan env)</span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="nottickedoff">case mbChan of</span>
<span class="lineno">  232 </span><span class="spaces">                </span><span class="nottickedoff">Just chan -&gt; writeChan chan (KeyboardCallback char)</span>
<span class="lineno">  233 </span><span class="spaces">                </span><span class="nottickedoff">Nothing   -&gt; return ()</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="nottickedoff">keyPressed _     _            _    _ _ = return ()</span></span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>-- Function to initiallize a framebuffer object (FBO) so that we can know whether FBOs are supported.
<span class="lineno">  242 </span>-- Will also possibly want to just test the OpenGL version string as an initial check before wasting the time to do this.
<span class="lineno">  243 </span>initFBO :: IO( (Ptr GLuint, Ptr GLuint) )
<span class="lineno">  244 </span><span class="decl"><span class="istickedoff">initFBO = do</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">-- Create a Framebuffer object and bind it</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff">fboIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">glGenFramebuffers 1 fboIdPtr</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">fboId &lt;- peek fboIdPtr</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">glBindFramebuffer gl_FRAMEBUFFER fboId</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">let w = 1</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">h = 1</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">{- </span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">-- Create a renderbuffer object to store depth info</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">rboIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">glGenRenderbuffers 1 rboIdPtr</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">rboId &lt;- peek rboIdPtr</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">glBindRenderbuffer gl_RENDERBUFFER rboId</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">glRenderbufferStorage gl_RENDERBUFFER gl_DEPTH_COMPONENT w h</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">glBindRenderbuffer gl_RENDERBUFFER 0</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">-- Attach the renderbuffer to the FBO depth attachment point</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">glFramebufferRenderbuffer gl_FRAMEBUFFER gl_DEPTH_ATTACHMENT gl_RENDERBUFFER rboId</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">--}</span>
<span class="lineno">  265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">-- Create a texture object and bind it    NEED: to abstract out the color (RGBA)</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">texIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">glGenTextures 1 texIdPtr</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId  </span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE </span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral gl_RGBA8) w h 0 gl_RGBA gl_UNSIGNED_BYTE nullPtr</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">-- Unbind this texture so it isn't the one currently being used</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="istickedoff">-- Attach the texture to a FBO color attachment point</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId 0</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">return (fboIdPtr, texIdPtr)</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- We need to come up with a better name for this function
<span class="lineno">  293 </span>-- Now, it only works *if* you already have a set of instructions to read.
<span class="lineno">  294 </span>changeBoard' :: CBenv -&gt; IO () -&gt; [Inst BufferId] -&gt; IO ()
<span class="lineno">  295 </span><span class="decl"><span class="istickedoff">changeBoard' env next changes = do</span>
<span class="lineno">  296 </span><span class="spaces"></span><span class="istickedoff">--    print &quot;changeBoard&quot;</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">{-</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">when (not (null changes)) $ do</span>
<span class="lineno">  299 </span><span class="spaces">       </span><span class="istickedoff">print changes</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">--}</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">--Draw all new instructions (into the textures with ptrs stored in the map)</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">--tm &lt;- liftIO $ getCurrentTime</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">drawInsts env changes</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">--tm' &lt;- liftIO $ getCurrentTime</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">{-</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ when (not (null changes)) $ do</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">print (diffUTCTime tm' tm)</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">--}</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">--fragMap2 &lt;- get (fracFunctionInfo env)</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">--print $ &quot;After: &quot; ++ (show $ size fragMap2)</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">debug &lt;- getDebugFrames env</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">curBoard &lt;- getCurrentBoard env</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">temp &lt;- get errors</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="istickedoff">when (not (null temp)) $ </span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">print (&quot;ERRORS&quot;,temp)</span></span>
<span class="lineno">  319 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">when (debug &amp;&amp; <span class="nottickedoff">(not (null changes))</span>) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  321 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">imgUnique &lt;- newUnique</span></span>
<span class="lineno">  322 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">imgNum &lt;- return $ hashUnique imgUnique</span></span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">appendFile &quot;./debug.html&quot; $ &quot;&lt;br&gt;&lt;pre&gt;&quot; ++ showCBIRs changes ++ &quot;&lt;/pre&gt;\n&quot;</span></span>
<span class="lineno">  324 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">appendFile &quot;./debug.html&quot; $ &quot;&lt;br&gt;\n&lt;img src=\&quot;debug-&quot; ++ show imgNum ++ &quot;.png\&quot;/&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;hr&gt;\n&lt;br&gt;\n&lt;br&gt;\n&quot;</span></span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">alreadyExists &lt;- doesFileExist $ &quot;./debug-&quot; ++ show imgNum ++ &quot;.png&quot;</span></span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">when (alreadyExists) $ removeFile (&quot;./debug-&quot; ++ show imgNum ++ &quot;.png&quot;)</span></span>
<span class="lineno">  327 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">saveImage env curBoard (&quot;./debug-&quot; ++ show imgNum ++ &quot;.png&quot;)</span></span>
<span class="lineno">  328 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  329 </span><span class="spaces">    </span><span class="istickedoff">addTimerCallback 20 $ next</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">displayCallback $= (drawBoard env)</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">postRedisplay Nothing</span></span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>-- Function to see if there were any new instructions passed in and if so to call the changeboard' function
<span class="lineno">  336 </span>--   * insts - An MVar possibly containing a list of CBIR instructions to make changes to the boards
<span class="lineno">  337 </span>changeBoard :: CBenv -&gt; MVar ([Inst BufferId]) -&gt; IO ()
<span class="lineno">  338 </span><span class="decl"><span class="istickedoff">changeBoard env insts = do</span>
<span class="lineno">  339 </span><span class="spaces"></span><span class="istickedoff">--    print &quot;changeBoard&quot;</span>
<span class="lineno">  340 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff">maybeInsts &lt;- tryTakeMVar insts</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff">let changes = fromMaybe [] maybeInsts</span>
<span class="lineno">  344 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">changeBoard' env (changeBoard env insts) changes</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>-- Display callback function to make sure the right framebuffer is bound and display the final display board.
<span class="lineno">  353 </span>drawBoard :: CBenv -&gt; IO ()
<span class="lineno">  354 </span><span class="decl"><span class="istickedoff">drawBoard env = do</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">-- First, see if we are using a FBO or not</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  357 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">fboSupp</span></span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="istickedoff">then do</span>
<span class="lineno">  360 </span><span class="spaces">            </span><span class="istickedoff">-- If using a FBO, get the ptr so we can reset it after displaying</span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="istickedoff">fboIdPtr &lt;- getFBOPtr env</span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="istickedoff">-- Reset the framebuffer to the actual window</span>
<span class="lineno">  363 </span><span class="spaces">            </span><span class="istickedoff">glBindFramebuffer gl_FRAMEBUFFER 0</span>
<span class="lineno">  364 </span><span class="spaces">            </span><span class="istickedoff">-- Draw the final board</span>
<span class="lineno">  365 </span><span class="spaces">            </span><span class="istickedoff">displayBoard env</span>
<span class="lineno">  366 </span><span class="spaces">            </span><span class="istickedoff">flush</span>
<span class="lineno">  367 </span><span class="spaces">            </span><span class="istickedoff">swapBuffers</span>
<span class="lineno">  368 </span><span class="spaces">            </span><span class="istickedoff">-- Change the framebuffer back so that we can start drawing boards again</span>
<span class="lineno">  369 </span><span class="spaces">            </span><span class="istickedoff">fboId &lt;- peek fboIdPtr</span>
<span class="lineno">  370 </span><span class="spaces">            </span><span class="istickedoff">glBindFramebuffer gl_FRAMEBUFFER fboId</span>
<span class="lineno">  371 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno">  372 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Draw the final board</span></span>
<span class="lineno">  373 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">displayBoard env</span></span>
<span class="lineno">  374 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">flush</span></span>
<span class="lineno">  375 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">swapBuffers</span></span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>{- Wrong placement in this refreash logic (which needs revisited)
<span class="lineno">  378 </span>    stream &lt;- readIORef (currentStream env)
<span class="lineno">  379 </span>    case stream of
<span class="lineno">  380 </span>        Nothing -&gt; return ()
<span class="lineno">  381 </span>        Just streamid -&gt; do
<span class="lineno">  382 </span>                b &lt;- getCurrentBoard env
<span class="lineno">  383 </span>               print &quot;Writing board to ffmpeg&quot;
<span class="lineno">  384 </span>                writeStream env b streamid
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>    -- sanity check; look for space leaks
<span class="lineno">  387 </span>    texMap &lt;- getTexMap env
<span class="lineno">  388 </span>    b &lt;- getCurrentBoard env
<span class="lineno">  389 </span>    when (Map.size texMap /= 1) $ do
<span class="lineno">  390 </span>       putStrLn &quot;There are boards still allocated&quot;
<span class="lineno">  391 </span>       print (Map.keys (Map.filterWithKey (\ k a -&gt; (k /= b)) texMap))
<span class="lineno">  392 </span>-}    
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>-- Function to display the current output board of a chalkboard image. Done once per frame.
<span class="lineno">  396 </span>displayBoard :: CBenv -&gt; IO ()
<span class="lineno">  397 </span><span class="decl"><span class="istickedoff">displayBoard env = do</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">b &lt;- getCurrentBoard env</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">-- Check to make sure the display board exists</span>
<span class="lineno">  402 </span><span class="spaces">    </span><span class="istickedoff">when (notMember b texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  403 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">print &quot;Error: The board to display doesn't exist.&quot;</span></span>
<span class="lineno">  404 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno">  405 </span><span class="spaces">            </span><span class="istickedoff"></span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">-- Get some info about the current output board</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="istickedoff">let (Just texInfo) = lookup b texMap</span>
<span class="lineno">  408 </span><span class="spaces">        </span><span class="istickedoff">texIdPtr = texPtr texInfo</span>
<span class="lineno">  409 </span><span class="spaces">        </span><span class="istickedoff">(w',h') = texSize texInfo</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">(w,h) = (fromIntegral w', fromIntegral h')</span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">{- Turn this off to center the image instead of snapping the window to its size</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">Size winW winH &lt;- get windowSize</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">when (winW /= fromIntegral w || winH /= fromIntegral h) $</span>
<span class="lineno">  417 </span><span class="spaces">        </span><span class="istickedoff">if (w &lt; 200)</span>
<span class="lineno">  418 </span><span class="spaces">            </span><span class="istickedoff">then do </span>
<span class="lineno">  419 </span><span class="spaces">                </span><span class="istickedoff">windowSize $= (Size 200 h)</span>
<span class="lineno">  420 </span><span class="spaces">                </span><span class="istickedoff">resizeScene (Size 200 h)</span>
<span class="lineno">  421 </span><span class="spaces">            </span><span class="istickedoff">else do</span>
<span class="lineno">  422 </span><span class="spaces">                </span><span class="istickedoff">windowSize $= (Size w h)</span>
<span class="lineno">  423 </span><span class="spaces">                </span><span class="istickedoff">resizeScene (Size w h)</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">--}</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">-- Calculations to center the image in the window</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff">Size winW2 winH2 &lt;- get windowSize -- Get the size of the window    </span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff">let minW = (fromIntegral winW2 - w) / 2.0</span>
<span class="lineno">  429 </span><span class="spaces">        </span><span class="istickedoff">minH = (fromIntegral winH2 - h) / 2.0</span>
<span class="lineno">  430 </span><span class="spaces">        </span><span class="istickedoff">maxW = (fromIntegral winW2 - minW)</span>
<span class="lineno">  431 </span><span class="spaces">        </span><span class="istickedoff">maxH = (fromIntegral winH2 - minH)</span>
<span class="lineno">  432 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">-- Bind the texture so that we can display it</span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">clearColor $= Color4 1 1 1 1 -- Clear the background color to white</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">clear [ColorBuffer, DepthBuffer] -- clear the screen and the depth buffer</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">loadIdentity -- reset view</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">color (Color4 1 1 1 (1::GL.GLfloat))</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">-- Display the final board, making sure that it is drawn in the upper left corner of the window (for now)</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">renderPrimitive Quads $ do</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 0 (1::GL.GLfloat)) -- Top Left</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 minW maxH (0::GL.GLfloat))</span>
<span class="lineno">  444 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 0 (0::GL.GLfloat)) -- Bottom Left</span>
<span class="lineno">  445 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 minW minH (0::GL.GLfloat)) -- Used to be GL.GLsizei</span>
<span class="lineno">  446 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 1 (0::GL.GLfloat)) -- Bottom Right</span>
<span class="lineno">  447 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 maxW minH (0::GL.GLfloat))</span>
<span class="lineno">  448 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 1 (1::GL.GLfloat)) -- Top Right</span>
<span class="lineno">  449 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 maxW maxH (0::GL.GLfloat))</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">-- Unbind the texture in case we need to keep writing to it later</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span></span>
<span class="lineno">  453 </span>
<span class="lineno">  454 </span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>-- Function to loop (recurse) through CBIR instructions and apply all of their effects to change or create boards
<span class="lineno">  462 </span>--   * (i:is)  - The list of CBIR instructions that are left to execute
<span class="lineno">  463 </span>drawInsts :: CBenv -&gt; [Inst BufferId] -&gt; IO ()
<span class="lineno">  464 </span><span class="decl"><span class="istickedoff">drawInsts _   []     = return <span class="nottickedoff">()</span></span>
<span class="lineno">  465 </span><span class="spaces"></span><span class="istickedoff">drawInsts env (i:is) = do </span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">case i of</span>
<span class="lineno">  467 </span><span class="spaces">            </span><span class="istickedoff">(Allocate b bsize depth (BackgroundByteString arr)) -&gt; allocateArrBuffer env b bsize depth arr</span>
<span class="lineno">  468 </span><span class="spaces">            </span><span class="istickedoff">(Allocate b bsize depth bgColor) -&gt; allocateBuffer env b bsize depth bgColor</span>
<span class="lineno">  469 </span><span class="spaces">            </span><span class="istickedoff">(AllocateImage b imagePath) -&gt; <span class="nottickedoff">allocateImgBuffer env b imagePath</span></span>
<span class="lineno">  470 </span><span class="spaces">            </span><span class="istickedoff">(Splat target blender stype) -&gt; splat env target blender stype</span>
<span class="lineno">  471 </span><span class="spaces">            </span><span class="istickedoff">(SaveImage b savePath) -&gt; saveImage env b savePath</span>
<span class="lineno">  472 </span><span class="spaces">            </span><span class="istickedoff">(OpenStream streamID cmd verb) -&gt; openStream env streamID cmd verb</span>
<span class="lineno">  473 </span><span class="spaces">            </span><span class="istickedoff">(WriteStream bufferID streamID) -&gt; writeStream env bufferID streamID</span>
<span class="lineno">  474 </span><span class="spaces">            </span><span class="istickedoff">(CloseStream streamID) -&gt; closeStream env streamID</span>
<span class="lineno">  475 </span><span class="spaces">            </span><span class="istickedoff">(Delete b) -&gt; deleteBuffer env b</span>
<span class="lineno">  476 </span><span class="spaces">            </span><span class="istickedoff">(Nested _ insts') -&gt; drawInsts env insts'</span>
<span class="lineno">  477 </span><span class="spaces">            </span><span class="istickedoff">(AllocFragmentShader f txt args) -&gt; allocFragmentShader env f txt <span class="nottickedoff">args</span></span>
<span class="lineno">  478 </span><span class="spaces">            </span><span class="istickedoff">(ChangeMouseCallback fn) -&gt; <span class="nottickedoff">changeMouseCallback env fn</span></span>
<span class="lineno">  479 </span><span class="spaces">            </span><span class="istickedoff">(ChangeKeyboardCallback fn) -&gt; <span class="nottickedoff">changeKeyboardCallback env fn</span></span>
<span class="lineno">  480 </span><span class="spaces">            </span><span class="istickedoff">(CBIR.Exit) -&gt; exitWith ExitSuccess </span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="istickedoff">drawInsts env is</span></span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>splat :: CBenv -&gt; BufferId -&gt; Blender -&gt; Splat BufferId -&gt; IO ()
<span class="lineno">  489 </span><span class="decl"><span class="istickedoff">splat env target blender stype = do</span>
<span class="lineno">  490 </span><span class="spaces">        </span><span class="istickedoff">case blender of</span>
<span class="lineno">  491 </span><span class="spaces">                </span><span class="istickedoff">CBIR.Blend -&gt; blendFuncSeparate $= ((SrcAlpha, OneMinusSrcAlpha), (One, OneMinusSrcAlpha))</span>
<span class="lineno">  492 </span><span class="spaces">                </span><span class="istickedoff">CBIR.Copy -&gt; blendFuncSeparate $= ((One, Zero), (One, Zero))</span>
<span class="lineno">  493 </span><span class="spaces">                </span><span class="istickedoff">CBIR.Sum -&gt; <span class="nottickedoff">blendFuncSeparate $= ((One, One), (One, One))</span> -- Adds the alphas at the moment</span>
<span class="lineno">  494 </span><span class="spaces">                </span><span class="istickedoff">CBIR.Max -&gt; blendEquation $= GLUT.Max</span>
<span class="lineno">  495 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno">  496 </span><span class="spaces">        </span><span class="istickedoff">case stype of</span>
<span class="lineno">  497 </span><span class="spaces">                </span><span class="istickedoff">(SplatPolygon' src ptMaps) -&gt; splatPolygon env src target ptMaps</span>
<span class="lineno">  498 </span><span class="spaces">                </span><span class="istickedoff">(SplatColor' scolor ptList) -&gt; splatColor env scolor target ptList</span>
<span class="lineno">  499 </span><span class="spaces">                </span><span class="istickedoff">(SplatBuffer' src) -&gt; splatPolygon env src target [ PointMap p p | p &lt;- [(0,0),(0,1),(1,1),(1,0)] ]</span>
<span class="lineno">  500 </span><span class="spaces">                </span><span class="istickedoff">(SplatFunction' fnId bargs uargs ptList) -&gt; splatWithFunction env fnId bargs uargs target ptList</span>
<span class="lineno">  501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  502 </span><span class="spaces">        </span><span class="istickedoff">blendFuncSeparate $= ((SrcAlpha, OneMinusSrcAlpha), (One, OneMinusSrcAlpha))</span>
<span class="lineno">  503 </span><span class="spaces">        </span><span class="istickedoff">blendEquation $= FuncAdd</span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>-- Function to allocate a new board/buffer object
<span class="lineno">  511 </span>--   * board - The buffer (board) object name
<span class="lineno">  512 </span>--   * (w,h) - The width and height of the new buffer being created
<span class="lineno">  513 </span>--   * d - The color depth of the buffer being created
<span class="lineno">  514 </span>--   * c - The initial color of the buffer that is being created
<span class="lineno">  515 </span>allocateBuffer :: CBenv -&gt; BufferId -&gt; (Int,Int) -&gt; Depth -&gt; Background -&gt; IO ()
<span class="lineno">  516 </span><span class="decl"><span class="istickedoff">allocateBuffer env board (w,h) d c = do</span>
<span class="lineno">  517 </span><span class="spaces">    </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  519 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  520 </span><span class="spaces">    </span><span class="istickedoff">-- Choose the internal format to use for this buffer based on the depth specified</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="istickedoff">let colorType = case d of</span>
<span class="lineno">  522 </span><span class="spaces">            </span><span class="istickedoff">BitDepth -&gt; <span class="nottickedoff">(fromIntegral gl_LUMINANCE)</span>   -- 8 bit per pixel (still grey, not just black and white)</span>
<span class="lineno">  523 </span><span class="spaces">            </span><span class="istickedoff">G8BitDepth -&gt; <span class="nottickedoff">(fromIntegral gl_LUMINANCE)</span> -- 8 bits per pixel (grey)</span>
<span class="lineno">  524 </span><span class="spaces">            </span><span class="istickedoff">RGB24Depth -&gt; (fromIntegral gl_RGB) -- (R,G,B), 8 bits per pixel</span>
<span class="lineno">  525 </span><span class="spaces">            </span><span class="istickedoff">RGBADepth -&gt; (fromIntegral gl_RGBA) -- (R,G,B,A), 8 bits per pixel</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="istickedoff">-- Choose the initial background color of the buffer based on the background specified</span>
<span class="lineno">  528 </span><span class="spaces">    </span><span class="istickedoff">let bgcolor = case c of </span>
<span class="lineno">  529 </span><span class="spaces">            </span><span class="istickedoff">(BackgroundBit on) -&gt; <span class="nottickedoff">if on then (Color4 0 0 0 1) else (Color4 1 1 1 1)</span> </span>
<span class="lineno">  530 </span><span class="spaces">            </span><span class="istickedoff">(BackgroundG8Bit grey) -&gt; <span class="nottickedoff">(Color4 (floatToGLclampf grey) (floatToGLclampf grey) (floatToGLclampf grey) 1)</span></span>
<span class="lineno">  531 </span><span class="spaces">            </span><span class="istickedoff">(BackgroundRGB24Depth (T.RGB r g b)) -&gt; (Color4 (floatToGLclampf r) (floatToGLclampf g) (floatToGLclampf b) 1)</span>
<span class="lineno">  532 </span><span class="spaces">            </span><span class="istickedoff">(BackgroundRGBADepth (T.RGBA r g b a)) -&gt; (Color4 (floatToGLclampf r) (floatToGLclampf g) (floatToGLclampf b) (floatToGLclampf a))</span>
<span class="lineno">  533 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">-- Create a texture object and bind it</span>
<span class="lineno">  535 </span><span class="spaces">    </span><span class="istickedoff">texIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  536 </span><span class="spaces">    </span><span class="istickedoff">glGenTextures 1 texIdPtr</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  538 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno">  539 </span><span class="spaces">       </span><span class="istickedoff"></span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="istickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="istickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR --Can maybe check into this now that generation is only done once</span>
<span class="lineno">  544 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  545 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  546 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="istickedoff">let texInfo = TextureInfo texIdPtr (fromIntegral w, fromIntegral h) <span class="nottickedoff">colorType</span></span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  549 </span><span class="spaces">    </span><span class="istickedoff">-- FBO is NOT unbound, nor is the texture image detached from the FBO</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">-- AJG: set before the call to bindFrameBufferToTexture</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff">setTexMap env (insert board texInfo texMap)</span>
<span class="lineno">  552 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">when (fboSupp) $ do</span>
<span class="lineno">  554 </span><span class="spaces">        </span><span class="istickedoff">-- Set up the texture so that it's image can be stored when drawing to the framebuffer</span>
<span class="lineno">  555 </span><span class="spaces">        </span><span class="istickedoff">-- colorType for both?</span>
<span class="lineno">  556 </span><span class="spaces">        </span><span class="istickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) (fromIntegral w) (fromIntegral h) 0 (fromIntegral colorType) gl_UNSIGNED_BYTE nullPtr </span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">-- Attach the texture to a FBO color attachment point</span>
<span class="lineno">  558 </span><span class="spaces">        </span><span class="istickedoff">bindFrameBufferToTexture env texId (Right board)</span>
<span class="lineno">  559 </span><span class="spaces">        </span><span class="istickedoff">-- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId 0</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  561 </span><span class="spaces">     </span><span class="istickedoff">-- TODO: there might be a faster way to do this than binding then clearing the color?</span>
<span class="lineno">  562 </span><span class="spaces">        </span><span class="istickedoff">-- KM: I believe these are both pretty light-weight operations and should be faster than drawing a</span>
<span class="lineno">  563 </span><span class="spaces">        </span><span class="istickedoff">--     single color polygon. I may be wrong though.</span>
<span class="lineno">  564 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">--preservingAttrib [ColorBufferAttributes] $ do --Temporarily change the clear color to make the buffer</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">do  clearColor $= bgcolor -- Change the clearColor to the color of the board being created</span>
<span class="lineno">  567 </span><span class="spaces">        </span><span class="istickedoff">clear [ColorBuffer] -- Clear the screen to the new color to draw that color onto the board</span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="istickedoff">clearColor $= Color4 1 1 1 1 -- Clear the background color to white</span>
<span class="lineno">  569 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  570 </span><span class="spaces">    </span><span class="istickedoff">when (not fboSupp) $ <span class="nottickedoff">do    </span></span>
<span class="lineno">  571 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Copy the texture from the framebuffer</span></span>
<span class="lineno">  572 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 colorType 0 0 (fromIntegral w) (fromIntegral h) 0</span></span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  574 </span><span class="spaces">    </span><span class="istickedoff">-- Unbind Texture until it is needed (may want to take this out depending on how we order instructions coming in)</span>
<span class="lineno">  575 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span></span>
<span class="lineno">  576 </span>    
<span class="lineno">  577 </span> 
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>
<span class="lineno">  580 </span>-- | How many bytes we pixel?
<span class="lineno">  581 </span>depthToBytes :: Depth -&gt; Int
<span class="lineno">  582 </span><span class="decl"><span class="istickedoff">depthToBytes BitDepth   = <span class="nottickedoff">1</span></span>
<span class="lineno">  583 </span><span class="spaces"></span><span class="istickedoff">depthToBytes G8BitDepth = <span class="nottickedoff">1</span></span>
<span class="lineno">  584 </span><span class="spaces"></span><span class="istickedoff">depthToBytes RGB24Depth = 3</span>
<span class="lineno">  585 </span><span class="spaces"></span><span class="istickedoff">depthToBytes RGBADepth  = 4</span></span>
<span class="lineno">  586 </span>
<span class="lineno">  587 </span>
<span class="lineno">  588 </span>{- I've cut and pasted this from allocateImgBuffer -}
<span class="lineno">  589 </span>-- TODO: merge with function allocateArrBuffer, because allocateRawImgBuffer is only called in one place
<span class="lineno">  590 </span>allocateRawImgBuffer :: CBenv -&gt; BufferId -&gt; (Int,Int) -&gt; Depth -&gt; Ptr CUChar -&gt; IO ()
<span class="lineno">  591 </span><span class="decl"><span class="istickedoff">allocateRawImgBuffer env board (w,h) depth imagePtr = do</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">--fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  595 </span><span class="spaces">    </span><span class="istickedoff">-- Just set the colorType to RGBA for now, this should maybe change so that they can use any format of image data </span>
<span class="lineno">  596 </span><span class="spaces">    </span><span class="istickedoff">let colorType = case depth of</span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="istickedoff">BitDepth -&gt; <span class="nottickedoff">(fromIntegral gl_LUMINANCE)</span>   -- 8 bit per pixel (still grey, not just black and white)</span>
<span class="lineno">  598 </span><span class="spaces">            </span><span class="istickedoff">G8BitDepth -&gt; <span class="nottickedoff">(fromIntegral gl_LUMINANCE)</span> -- 8 bits per pixel (grey)</span>
<span class="lineno">  599 </span><span class="spaces">            </span><span class="istickedoff">RGB24Depth -&gt; (fromIntegral gl_RGB) -- (R,G,B), 8 bits per pixel</span>
<span class="lineno">  600 </span><span class="spaces">            </span><span class="istickedoff">RGBADepth -&gt; (fromIntegral gl_RGBA) -- (R,G,B,A), 8 bits per pixel</span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  602 </span><span class="spaces">    </span><span class="istickedoff">-- Create a texture object and bind it</span>
<span class="lineno">  603 </span><span class="spaces">    </span><span class="istickedoff">texIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="istickedoff">glGenTextures 1 texIdPtr</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno">  607 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="istickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR --Can maybe check into this now that generation is only done once</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) (fromIntegral w) (fromIntegral h) 0 (fromIntegral colorType) gl_UNSIGNED_BYTE (castPtr imagePtr)</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="istickedoff">let texInfo = TextureInfo texIdPtr <span class="nottickedoff">(fromIntegral w, fromIntegral h)</span> <span class="nottickedoff">colorType</span></span>
<span class="lineno">  618 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="istickedoff">-- Unbind this texture so it isn't the one currently being used</span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno">  621 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  622 </span><span class="spaces">    </span><span class="istickedoff">-- FBO is NOT unbound, nor is the texture image detached from the FBO</span>
<span class="lineno">  623 </span><span class="spaces">    </span><span class="istickedoff">setTexMap env (insert board texInfo texMap)</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>{-
<span class="lineno">  626 </span>    -- Done to mirror the other allocates (leaving the texture attached to the fbo), but should maybe just get rid of this:
<span class="lineno">  627 </span>    -- TODO: remove this
<span class="lineno">  628 </span>    when (fboSupp) $ do
<span class="lineno">  629 </span>            -- Attach the texture to a FBO color attachment point
<span class="lineno">  630 </span>            bindFrameBufferToTexture env texId (Right board)
<span class="lineno">  631 </span>            -- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId 0
<span class="lineno">  632 </span>-}
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>allocateArrBuffer :: CBenv -&gt; BufferId -&gt; (Int,Int) -&gt; Depth -&gt; ByteString -&gt; IO ()
<span class="lineno">  639 </span><span class="decl"><span class="istickedoff">allocateArrBuffer env board (w,h) depth bs = do</span>
<span class="lineno">  640 </span><span class="spaces">        </span><span class="istickedoff">do let (fptr,off,len) = toForeignPtr bs</span>
<span class="lineno">  641 </span><span class="spaces">                    </span><span class="istickedoff">-- assert len == w * h * depth</span>
<span class="lineno">  642 </span><span class="spaces">           </span><span class="istickedoff">if <span class="tickonlytrue">len == w * h * depthToBytes depth</span></span>
<span class="lineno">  643 </span><span class="spaces">                </span><span class="istickedoff">then withForeignPtr fptr $ \ p -&gt; do</span>
<span class="lineno">  644 </span><span class="spaces">                                </span><span class="istickedoff">allocateRawImgBuffer env board (w,h) depth (plusPtr (castPtr p) off)</span>
<span class="lineno">  645 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">error $ &quot;allocateArrBuffer problem &quot; ++ show (len,w*h,depthToBytes depth)</span></span></span>
<span class="lineno">  646 </span>
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>-- Function to allocate a new board/buffer object using a pre-existing image
<span class="lineno">  650 </span>--   * board - The buffer (board) object name
<span class="lineno">  651 </span>--   * imagePath - The path to the image file being loading into this new buffer
<span class="lineno">  652 </span>allocateImgBuffer :: CBenv -&gt; BufferId -&gt; FilePath -&gt; IO ()
<span class="lineno">  653 </span><span class="decl"><span class="nottickedoff">allocateImgBuffer env board imagePath = do</span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="nottickedoff">--fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  655 </span><span class="spaces">    </span><span class="nottickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  657 </span><span class="spaces">    </span><span class="nottickedoff">-- Just set the colorType to RGBA for now</span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="nottickedoff">let colorType = gl_RGBA</span>
<span class="lineno">  659 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="nottickedoff">-- Create a texture object and bind it</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="nottickedoff">texIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="nottickedoff">glGenTextures 1 texIdPtr</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="nottickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  664 </span><span class="spaces">    </span><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="nottickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="nottickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR --Can maybe check into this now that generation is only done once</span>
<span class="lineno">  670 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  671 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  673 </span><span class="spaces">    </span><span class="nottickedoff">-- Read in the image to an array from the filepath that was given using devIL</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="nottickedoff">arr &lt;- readImage imagePath</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="nottickedoff">--tm2 &lt;- getCurrentTime</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="nottickedoff">-- Get the array data and give that to an openGL texture</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="nottickedoff">let ((0,0,0), (h,w,3)) = U.bounds arr</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="nottickedoff">arrT &lt;- unsafeThaw arr</span>
<span class="lineno">  680 </span><span class="spaces">    </span><span class="nottickedoff">--tm2' &lt;- getCurrentTime</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="nottickedoff">--print (diffUTCTime tm2' tm2)</span>
<span class="lineno">  682 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="nottickedoff">withStorableArray arrT $ \ptr -&gt; do</span>
<span class="lineno">  684 </span><span class="spaces">        </span><span class="nottickedoff">-- Might have to just do RGBA instead of colorType!!!</span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="nottickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) (fromIntegral w+1) (fromIntegral h+1) 0 (fromIntegral colorType) gl_UNSIGNED_BYTE (castPtr ptr)</span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="nottickedoff">let texInfo = TextureInfo texIdPtr (fromIntegral w+1, fromIntegral h+1) colorType</span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="nottickedoff">-- Unbind this texture so it isn't the one currently being used</span>
<span class="lineno">  690 </span><span class="spaces">    </span><span class="nottickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="nottickedoff">-- FBO is NOT unbound, nor is the texture image detached from the FBO</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="nottickedoff">setTexMap env (insert board texInfo texMap)</span></span>
<span class="lineno">  694 </span>{-
<span class="lineno">  695 </span>    -- Done to mirror the other allocates (leaving the texture attached to the fbo), but should maybe just get rid of this:
<span class="lineno">  696 </span>    when (fboSupp) $ do
<span class="lineno">  697 </span>            -- Attach the texture to a FBO color attachment point
<span class="lineno">  698 </span>            bindFrameBufferToTexture env texId (Right board)
<span class="lineno">  699 </span>            -- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId 0
<span class="lineno">  700 </span>-}
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>
<span class="lineno">  703 </span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>-- Function to splat a polygon from one source buffer to one destination buffer
<span class="lineno">  710 </span>--   * bS - The source buffer (board) object name
<span class="lineno">  711 </span>--   * bD - The destination buffer (board) object name
<span class="lineno">  712 </span>--   * ps - A list of PointMaps, which specify a pairing of points: one on the source buffer that correspond one on the destination buffer
<span class="lineno">  713 </span>splatPolygon :: CBenv -&gt; BufferId -&gt; BufferId -&gt; [PointMap] -&gt; IO ()
<span class="lineno">  714 </span><span class="decl"><span class="istickedoff">splatPolygon env bS bD ps = do</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  717 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  718 </span><span class="spaces">    </span><span class="istickedoff">-- Check to make sure both the source and destination boards exist</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">when (notMember bD texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  720 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">print &quot;Error: The destination board to splat to doesn't exist. (splat polygon)&quot;</span></span>
<span class="lineno">  721 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno">  722 </span><span class="spaces">    </span><span class="istickedoff">when (notMember bS texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  723 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">print &quot;Error: The source board to splat doesn't exist.&quot;</span></span>
<span class="lineno">  724 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  726 </span><span class="spaces">    </span><span class="istickedoff">-- Look up all of the values that will be needed</span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">let (Just texInfoD) = lookup bD texMap</span>
<span class="lineno">  728 </span><span class="spaces">        </span><span class="istickedoff">(Just texInfoS) = lookup bS texMap</span>
<span class="lineno">  729 </span><span class="spaces">        </span><span class="istickedoff">texIdPtrD = texPtr texInfoD</span>
<span class="lineno">  730 </span><span class="spaces">        </span><span class="istickedoff">texIdPtrS' = texPtr texInfoS</span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff">(w,h) = texSize texInfoD</span>
<span class="lineno">  732 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">colorType = texFormat texInfoD</span></span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="istickedoff">texIdD &lt;- peek texIdPtrD</span>
<span class="lineno">  735 </span><span class="spaces">    </span><span class="istickedoff">texIdS' &lt;- peek texIdPtrS'</span>
<span class="lineno">  736 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">(not fboSupp)</span></span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff">then <span class="nottickedoff">do</span></span>
<span class="lineno">  739 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">clear [DepthBuffer] -- clear the depth buffer</span></span>
<span class="lineno">  740 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">loadIdentity</span></span>
<span class="lineno">  741 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">--Bind the destination texture to use first</span></span>
<span class="lineno">  742 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texIdD</span></span>
<span class="lineno">  743 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Turn off blending so the destination board isn't blended with the background color</span></span>
<span class="lineno">  744 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">blend $= Disabled</span></span>
<span class="lineno">  745 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Render the destination board so we can draw onto it</span></span>
<span class="lineno">  746 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">renderPrimitive Quads $ do</span></span>
<span class="lineno">  747 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 0 (0::GL.GLfloat)) -- Bottom Left</span></span>
<span class="lineno">  748 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 0 0 (0::GL.GLfloat)) -- Used to be GLUT.GLsizei, does it matter?</span></span>
<span class="lineno">  749 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 1 (0::GL.GLfloat)) -- Bottom Right</span></span>
<span class="lineno">  750 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 (fromIntegral w) 0 (0::GL.GLfloat))</span></span>
<span class="lineno">  751 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 1 (1::GL.GLfloat)) -- Top Right</span></span>
<span class="lineno">  752 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 (fromIntegral w) (fromIntegral h) (0::GL.GLfloat))</span></span>
<span class="lineno">  753 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 0 (1::GL.GLfloat)) -- Top Left</span></span>
<span class="lineno">  754 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 0 (fromIntegral h) (0::GL.GLfloat))</span></span>
<span class="lineno">  755 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Turn blending back on so that the source board can be blended with the destination board</span></span>
<span class="lineno">  756 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">blend $= Enabled</span></span>
<span class="lineno">  757 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  758 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Bind the source texture that will be splatted on    </span></span>
<span class="lineno">  759 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texIdS'</span></span>
<span class="lineno">  760 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">--Uses relative positions (percentages) of source and destination boards</span></span>
<span class="lineno">  761 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">renderPrimitive Polygon $</span></span>
<span class="lineno">  762 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">placeVerticies w h ps</span></span>
<span class="lineno">  763 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  764 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Bind the destination texture so we can copy the new image out to it</span></span>
<span class="lineno">  765 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texIdD</span></span>
<span class="lineno">  766 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Copy the texture from the framebuffer (make more efficient by only copying the changed subimage?)</span></span>
<span class="lineno">  767 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) 0 0 (fromIntegral w) (fromIntegral h) 0</span> </span>
<span class="lineno">  768 </span><span class="spaces">            </span><span class="istickedoff"></span>
<span class="lineno">  769 </span><span class="spaces">        </span><span class="istickedoff">else do</span>
<span class="lineno">  770 </span><span class="spaces">            </span><span class="istickedoff">-- Attach the texture to a FBO color attachment point</span>
<span class="lineno">  771 </span><span class="spaces">            </span><span class="istickedoff">bindFrameBufferToTexture env texIdD (Right bD)</span>
<span class="lineno">  772 </span><span class="spaces">            </span><span class="istickedoff">-- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texIdD 0</span>
<span class="lineno">  773 </span><span class="spaces">            </span><span class="istickedoff">-- Check to see if the texture is trying to recursively draw onto itself, and if so create a copy of the source texture</span>
<span class="lineno">  774 </span><span class="spaces">            </span><span class="istickedoff">-- to prevent the undefined feedback loop that would result from drawing straight to the same texture that is being read</span>
<span class="lineno">  775 </span><span class="spaces">            </span><span class="istickedoff">(texIdS, texIdPtrS) &lt;- if <span class="tickonlyfalse">(texIdD == texIdS')</span></span>
<span class="lineno">  776 </span><span class="spaces">                                       </span><span class="istickedoff">then <span class="nottickedoff">fixTexLoopback texInfoS</span> --Could call after binding texIdS' to avoid an extra binding or two maybe?</span>
<span class="lineno">  777 </span><span class="spaces">                                       </span><span class="istickedoff">else return (texIdS', <span class="nottickedoff">texIdPtrS'</span>)</span>
<span class="lineno">  778 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  779 </span><span class="spaces">            </span><span class="istickedoff">-- Bind the source texture that will be splatted on    </span>
<span class="lineno">  780 </span><span class="spaces">            </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texIdS</span>
<span class="lineno">  781 </span><span class="spaces">            </span><span class="istickedoff">--Uses relative positions (percentages) of source and destination boards</span>
<span class="lineno">  782 </span><span class="spaces">            </span><span class="istickedoff">renderPrimitive Polygon $</span>
<span class="lineno">  783 </span><span class="spaces">                </span><span class="istickedoff">placeVerticies w h ps  </span>
<span class="lineno">  784 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  785 </span><span class="spaces">            </span><span class="istickedoff">-- If a new source texture was created to prevent a feedback loop, then delete it</span>
<span class="lineno">  786 </span><span class="spaces">            </span><span class="istickedoff">when (texIdS /= texIdS') $ <span class="nottickedoff">do</span></span>
<span class="lineno">  787 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">glDeleteTextures 1 texIdPtrS</span></span>
<span class="lineno">  788 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  789 </span><span class="spaces">            </span><span class="istickedoff">-- Unbind Texture until it is needed (may want to take this out depending on how we order instructions coming in)</span>
<span class="lineno">  790 </span><span class="spaces">            </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span></span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>-- Function to place all of the tex coords and verticies of a polygon splat from a list of PointMaps.
<span class="lineno">  800 </span>--   * w  - The width of the destination board.
<span class="lineno">  801 </span>--   * h  - The height of the destination board.
<span class="lineno">  802 </span>--   * ps - The list of PointMaps from the source board onto the destination board.
<span class="lineno">  803 </span>placeVerticies :: GLint -&gt; GLint -&gt; [PointMap] -&gt; IO () -- Could maybe just make the first two as type 'a', which would be an integral
<span class="lineno">  804 </span><span class="decl"><span class="istickedoff">placeVerticies _ _ [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  805 </span><span class="spaces"></span><span class="istickedoff">placeVerticies w h (p:ps) = do</span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="istickedoff">let (PointMap (sx,sy) (dx,dy)) = p</span>
<span class="lineno">  807 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="istickedoff">texCoord (TexCoord2 (floatToGLfloat sx) ((floatToGLfloat sy)::GL.GLfloat))</span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w * floatToGLfloat dx) (fromIntegral h * floatToGLfloat dy) (1::GL.GLfloat))</span>
<span class="lineno">  810 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  811 </span><span class="spaces">    </span><span class="istickedoff">placeVerticies w h ps</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>-- Function to place all of the verticies of a color splat from a list of PointMaps.
<span class="lineno">  815 </span>--   * w  - The width of the destination board.
<span class="lineno">  816 </span>--   * h  - The height of the destination board.
<span class="lineno">  817 </span>--   * ps - The list of UIPoints to splat a color shape onto the destination board.
<span class="lineno">  818 </span>placeColorVerticies :: GLint -&gt; GLint -&gt; [UIPoint] -&gt; IO () -- Could maybe just make the first two as type 'a', which would be an integral
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">placeColorVerticies _ _ [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  820 </span><span class="spaces"></span><span class="istickedoff">placeColorVerticies w h (p:ps) = do</span>
<span class="lineno">  821 </span><span class="spaces">    </span><span class="istickedoff">let (dx,dy) = p</span>
<span class="lineno">  822 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  823 </span><span class="spaces">    </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w  * floatToGLfloat dx) (fromIntegral h * floatToGLfloat dy) (1::GL.GLfloat))</span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  825 </span><span class="spaces">    </span><span class="istickedoff">placeColorVerticies w h ps</span></span>
<span class="lineno">  826 </span>
<span class="lineno">  827 </span>
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>-- Function to create a new source texture when a board recursively draws onto itself using a FBO
<span class="lineno">  830 </span>-- This prevents a feedback loop with undefined behavior that would draw and read from the same texture at the same time
<span class="lineno">  831 </span>--   * texInfoS - the texture information for the texture that is supposed to be drawn onto itself
<span class="lineno">  832 </span>--   returns - the new texture id of the copied texture and the pointer to this new texture (used to delete it)
<span class="lineno">  833 </span>fixTexLoopback :: TextureInfo -&gt; IO ( (GLuint, Ptr GLuint) )
<span class="lineno">  834 </span><span class="decl"><span class="nottickedoff">fixTexLoopback texInfoS = do</span>
<span class="lineno">  835 </span><span class="spaces">    </span><span class="nottickedoff">let (w,h) = texSize texInfoS</span>
<span class="lineno">  836 </span><span class="spaces">        </span><span class="nottickedoff">colorType = texFormat texInfoS</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  838 </span><span class="spaces">    </span><span class="nottickedoff">-- Create and bind a new texture object to use as the source texture for splating</span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="nottickedoff">texIdPtr &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  840 </span><span class="spaces">    </span><span class="nottickedoff">glGenTextures 1 texIdPtr</span>
<span class="lineno">  841 </span><span class="spaces">    </span><span class="nottickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  842 </span><span class="spaces">    </span><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno">  843 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  844 </span><span class="spaces">    </span><span class="nottickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  845 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  846 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  847 </span><span class="spaces">    </span><span class="nottickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="nottickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  850 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  851 </span><span class="spaces">    </span><span class="nottickedoff">-- Copy the texture from the current FBO</span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) 0 0 (fromIntegral w) (fromIntegral h) 0</span>
<span class="lineno">  853 </span><span class="spaces">    </span><span class="nottickedoff">-- Unbind the new texture</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="nottickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno">  855 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">  856 </span><span class="spaces">    </span><span class="nottickedoff">return (texId, texIdPtr)</span></span>
<span class="lineno">  857 </span>
<span class="lineno">  858 </span>
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>
<span class="lineno">  862 </span>
<span class="lineno">  863 </span>
<span class="lineno">  864 </span>
<span class="lineno">  865 </span>-- Function to splat a color polygon onto one destination buffer
<span class="lineno">  866 </span>--   * (r,g,b,a) - The color to splat onto the destination board
<span class="lineno">  867 </span>--   * bD - The destination buffer (board) object name
<span class="lineno">  868 </span>--   * ps - A list of UIPoints, which specify the points of the colored polygon to draw onto the destination buffer
<span class="lineno">  869 </span>splatColor :: CBenv -&gt; RGBA -&gt; BufferId -&gt; [UIPoint] -&gt; IO ()
<span class="lineno">  870 </span><span class="decl"><span class="istickedoff">splatColor env (T.RGBA r g b a) bD ps = do</span>
<span class="lineno">  871 </span><span class="spaces">    </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  873 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff">-- Check to make sure the destination board exists</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="istickedoff">when (notMember bD texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  876 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">print &quot;Error: The destination board to splat to doesn't exist. (splat color)&quot;</span></span>
<span class="lineno">  877 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno">  878 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  879 </span><span class="spaces">    </span><span class="istickedoff">-- Look up all of the values that will be needed</span>
<span class="lineno">  880 </span><span class="spaces">    </span><span class="istickedoff">let (Just texInfoD) = lookup bD texMap</span>
<span class="lineno">  881 </span><span class="spaces">        </span><span class="istickedoff">texIdPtrD = texPtr texInfoD</span>
<span class="lineno">  882 </span><span class="spaces">        </span><span class="istickedoff">(w,h) = texSize texInfoD</span>
<span class="lineno">  883 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">colorType = texFormat texInfoD</span></span>
<span class="lineno">  884 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno">  885 </span><span class="spaces">    </span><span class="istickedoff">texIdD &lt;- peek texIdPtrD</span>
<span class="lineno">  886 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">(not fboSupp)</span></span>
<span class="lineno">  888 </span><span class="spaces">        </span><span class="istickedoff">then <span class="nottickedoff">do</span></span>
<span class="lineno">  889 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">clear [DepthBuffer] -- clear the depth buffer</span></span>
<span class="lineno">  890 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">loadIdentity</span></span>
<span class="lineno">  891 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">--Bind the destination texture to use first</span></span>
<span class="lineno">  892 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texIdD</span></span>
<span class="lineno">  893 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Turn off blending so the destination board isn't blended with the background color</span></span>
<span class="lineno">  894 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">blend $= Disabled</span></span>
<span class="lineno">  895 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Render the destination board so we can draw onto it</span></span>
<span class="lineno">  896 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">renderPrimitive Quads $ do</span></span>
<span class="lineno">  897 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 0 (0::GL.GLfloat)) -- Bottom Left</span></span>
<span class="lineno">  898 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 0 0 (0::GL.GLfloat)) -- Used to be GL.GLsizei, does it matter?</span></span>
<span class="lineno">  899 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 1 (0::GL.GLfloat)) -- Bottom Right</span></span>
<span class="lineno">  900 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 (fromIntegral w) 0 (0::GL.GLfloat))</span></span>
<span class="lineno">  901 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 1 (1::GL.GLfloat)) -- Top Right</span></span>
<span class="lineno">  902 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 (fromIntegral w) (fromIntegral h) (0::GL.GLfloat))</span></span>
<span class="lineno">  903 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">texCoord (TexCoord2 0 (1::GL.GLfloat)) -- Top Left</span></span>
<span class="lineno">  904 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">vertex (Vertex3 0 (fromIntegral h) (0::GL.GLfloat))</span></span>
<span class="lineno">  905 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Turn blending back on so that the source board can be blended with the destination board</span></span>
<span class="lineno">  906 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">blend $= Enabled</span></span>
<span class="lineno">  907 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Unbind the texture to prevent mapping - doesn't work if this is removed.</span></span>
<span class="lineno">  908 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D 0</span></span>
<span class="lineno">  909 </span><span class="spaces">        </span><span class="istickedoff">else do</span>
<span class="lineno">  910 </span><span class="spaces">            </span><span class="istickedoff">-- Attach the texture to a FBO color attachment point</span>
<span class="lineno">  911 </span><span class="spaces">            </span><span class="istickedoff">-- AJG: This is also taking a lot of time, presumbily because it stalls the pipeline.</span>
<span class="lineno">  912 </span><span class="spaces">            </span><span class="istickedoff">-- We can store what we've alread done, and not redo this for each target.</span>
<span class="lineno">  913 </span><span class="spaces">            </span><span class="istickedoff">bindFrameBufferToTexture env texIdD (Right bD)</span>
<span class="lineno">  914 </span><span class="spaces">            </span><span class="istickedoff">-- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texIdD 0</span>
<span class="lineno">  915 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  916 </span><span class="spaces">    </span><span class="istickedoff">-- Switch the color to the one we are trying to splat</span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="istickedoff">color (Color4 (floatToGLclampf r) (floatToGLclampf g) (floatToGLclampf b) ((floatToGLclampf a)::GLclampf))</span>
<span class="lineno">  918 </span><span class="spaces">    </span><span class="istickedoff">-- Uses relative positions (percentages) of source and destination boards</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">-- most of the time is attributed to *renderPrimitive* (glBegin?)</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">renderPrimitive Polygon $ do</span>
<span class="lineno">  921 </span><span class="spaces">        </span><span class="istickedoff">placeColorVerticies w h ps</span>
<span class="lineno">  922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">when (not fboSupp) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  924 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Bind the destination texture so we can copy the new image out to it</span></span>
<span class="lineno">  925 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D texIdD</span></span>
<span class="lineno">  926 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Copy the texture from the framebuffer</span></span>
<span class="lineno">  927 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) 0 0 (fromIntegral w) (fromIntegral h) 0 --make more efficient by only copying the changed subimage?</span></span>
<span class="lineno">  928 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Unbind Texture until it is needed (may want to take this out depending on how we order instructions coming in)</span></span>
<span class="lineno">  929 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">glBindTexture gl_TEXTURE_2D 0</span></span></span>
<span class="lineno">  930 </span>
<span class="lineno">  931 </span>
<span class="lineno">  932 </span>
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>
<span class="lineno">  935 </span>
<span class="lineno">  936 </span>-- Function to copy the image from one buffer into another buffer (using either its original alpha or the destination buffer's alpha)
<span class="lineno">  937 </span>--   * alpha - WithSrcAlpha to do a normal copy, keeping its own alpha values. WithDestAlpha to use the destination buffer's alpha values
<span class="lineno">  938 </span>--   * bS - The source buffer id
<span class="lineno">  939 </span>--   * bD - The destination buffer id
<span class="lineno">  940 </span>copyBuffer :: CBenv -&gt; WithAlpha -&gt; BufferId -&gt; BufferId -&gt; IO ()
<span class="lineno">  941 </span><span class="decl"><span class="nottickedoff">copyBuffer env alpha bS bD = do</span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="nottickedoff">case alpha of</span>
<span class="lineno">  943 </span><span class="spaces">            </span><span class="nottickedoff">WithSrcAlpha -&gt; do</span>
<span class="lineno">  944 </span><span class="spaces">                    </span><span class="nottickedoff">blendFuncSeparate $= ((One, Zero), (One, Zero))</span>
<span class="lineno">  945 </span><span class="spaces">                    </span><span class="nottickedoff">splatPolygon env bS bD [ PointMap p p | p &lt;- [(0,0),(0,1),(1,1),(1,0)] ]</span>
<span class="lineno">  946 </span><span class="spaces">                    </span><span class="nottickedoff">blendFuncSeparate $= ((SrcAlpha, OneMinusSrcAlpha), (One, OneMinusSrcAlpha))</span>
<span class="lineno">  947 </span><span class="spaces">            </span><span class="nottickedoff">WithDestAlpha -&gt; do</span>
<span class="lineno">  948 </span><span class="spaces">                    </span><span class="nottickedoff">blendFuncSeparate $= ((One, Zero), (Zero, One))</span>
<span class="lineno">  949 </span><span class="spaces">                    </span><span class="nottickedoff">splatPolygon env bS bD [ PointMap p p | p &lt;- [(0,0),(0,1),(1,1),(1,0)] ]</span>
<span class="lineno">  950 </span><span class="spaces">                    </span><span class="nottickedoff">blendFuncSeparate $= ((SrcAlpha, OneMinusSrcAlpha), (One, OneMinusSrcAlpha))</span></span>
<span class="lineno">  951 </span>
<span class="lineno">  952 </span>
<span class="lineno">  953 </span>
<span class="lineno">  954 </span>
<span class="lineno">  955 </span>
<span class="lineno">  956 </span>
<span class="lineno">  957 </span>-- Function to save an image out to a file from a specified board/buffer
<span class="lineno">  958 </span>--   * b        - The name of the buffer (board) object that will be saved out to a file
<span class="lineno">  959 </span>--   * savePath - The file path to the location where the image should be saved (including the image filename and extension)
<span class="lineno">  960 </span>-- This could maybe save a lot of code by just calling splatPolygon, but there may be complications.
<span class="lineno">  961 </span>saveImage :: CBenv -&gt; BufferId -&gt; FilePath -&gt; IO ()
<span class="lineno">  962 </span><span class="decl"><span class="istickedoff">saveImage env b savePath = do</span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno">  964 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno">  965 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  966 </span><span class="spaces">    </span><span class="istickedoff">-- Check to make sure the board being saved exists</span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="istickedoff">when (notMember b texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  968 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">print (&quot;Error: The board to be saved doesn't exist: &quot; ++ show b)</span></span>
<span class="lineno">  969 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno">  970 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  971 </span><span class="spaces">    </span><span class="istickedoff">-- Check if an image with the same name already exists. If it does, delete it.</span>
<span class="lineno">  972 </span><span class="spaces">    </span><span class="istickedoff">alreadyExists &lt;- doesFileExist $ savePath</span>
<span class="lineno">  973 </span><span class="spaces">    </span><span class="istickedoff">when (alreadyExists) $ removeFile savePath</span>
<span class="lineno">  974 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  975 </span><span class="spaces">    </span><span class="istickedoff">-- Look up the board we need to save</span>
<span class="lineno">  976 </span><span class="spaces">    </span><span class="istickedoff">let (Just texInfo) = lookup b texMap</span>
<span class="lineno">  977 </span><span class="spaces">        </span><span class="istickedoff">texIdPtr = texPtr texInfo</span>
<span class="lineno">  978 </span><span class="spaces">        </span><span class="istickedoff">(w,h) = texSize texInfo</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  980 </span><span class="spaces">    </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno">  981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="istickedoff">-- Create and bind a new texture object to use as the RGBA texture for outputting</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">texIdPtr2 &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="istickedoff">glGenTextures 1 texIdPtr2</span>
<span class="lineno">  985 </span><span class="spaces">    </span><span class="istickedoff">texId2 &lt;- peek texIdPtr2</span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId2</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  988 </span><span class="spaces">    </span><span class="istickedoff">--Set up the texture object and its parameters</span>
<span class="lineno">  989 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  990 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno">  991 </span><span class="spaces">    </span><span class="istickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR</span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  993 </span><span class="spaces">    </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno">  994 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  995 </span><span class="spaces">    </span><span class="istickedoff">when (fboSupp) $ do</span>
<span class="lineno">  996 </span><span class="spaces">            </span><span class="istickedoff">-- Create the new texture object so that we can draw directly into it</span>
<span class="lineno">  997 </span><span class="spaces">            </span><span class="istickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral gl_RGBA) (fromIntegral w) (fromIntegral h) 0 gl_RGBA gl_UNSIGNED_BYTE nullPtr</span>
<span class="lineno">  998 </span><span class="spaces">            </span><span class="istickedoff">-- Attach the new texture to a FBO color attachment point</span>
<span class="lineno">  999 </span><span class="spaces">            </span><span class="istickedoff">bindFrameBufferToTexture <span class="nottickedoff">env</span> texId2 (Left (w,h))</span>
<span class="lineno"> 1000 </span><span class="spaces">            </span><span class="istickedoff">-- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId2 0</span>
<span class="lineno"> 1001 </span><span class="spaces">            </span><span class="istickedoff"></span>
<span class="lineno"> 1002 </span><span class="spaces">    </span><span class="istickedoff">-- Bind the original (non-RGBA) texture so that it can be copied into the new one</span>
<span class="lineno"> 1003 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno"> 1004 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1005 </span><span class="spaces">    </span><span class="istickedoff">clear [ColorBuffer, DepthBuffer] -- clear the screen and the depth buffer</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="istickedoff">loadIdentity -- reset view</span>
<span class="lineno"> 1007 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1008 </span><span class="spaces">    </span><span class="istickedoff">color (Color4 1 1 1 (1::GL.GLfloat))</span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">-- Render the final board we want to save to file</span>
<span class="lineno"> 1010 </span><span class="spaces">    </span><span class="istickedoff">renderPrimitive Quads $ do</span>
<span class="lineno"> 1011 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 0 (0::GL.GLfloat)) -- Bottom Left</span>
<span class="lineno"> 1012 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 0 0 (0::GL.GLfloat)) -- Used to be GL.GLsizei, does it matter?</span>
<span class="lineno"> 1013 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 1 (0::GL.GLfloat)) -- Bottom Right</span>
<span class="lineno"> 1014 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w) 0 (0::GL.GLfloat))</span>
<span class="lineno"> 1015 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 1 (1::GL.GLfloat)) -- Top Right</span>
<span class="lineno"> 1016 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w) (fromIntegral h) (0::GL.GLfloat))</span>
<span class="lineno"> 1017 </span><span class="spaces">        </span><span class="istickedoff">texCoord (TexCoord2 0 (1::GL.GLfloat)) -- Top Left</span>
<span class="lineno"> 1018 </span><span class="spaces">        </span><span class="istickedoff">vertex (Vertex3 0 (fromIntegral h) (0::GL.GLfloat))</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="istickedoff">-- Bind the new texture again so that it can be saved</span>
<span class="lineno"> 1021 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId2</span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1023 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">(fboSupp)</span></span>
<span class="lineno"> 1024 </span><span class="spaces">        </span><span class="istickedoff">then do</span>
<span class="lineno"> 1025 </span><span class="spaces">            </span><span class="istickedoff">-- Unattach the new texture from the FBO color attachment point since it will be deleted</span>
<span class="lineno"> 1026 </span><span class="spaces">            </span><span class="istickedoff">cbBrd &lt;- getCurrentBoard env</span>
<span class="lineno"> 1027 </span><span class="spaces">            </span><span class="istickedoff">bindFrameBufferToTexture env 0 (Right cbBrd)</span>
<span class="lineno"> 1028 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno"> 1029 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Copy the texture from the screen to the new texture for saving</span></span>
<span class="lineno"> 1030 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 (fromIntegral gl_RGBA) 0 0 (fromIntegral w) (fromIntegral h) 0</span>   </span>
<span class="lineno"> 1031 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1032 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1033 </span><span class="spaces">    </span><span class="istickedoff">-- Create a new array with the image data so that we can write it out with devIL</span>
<span class="lineno"> 1034 </span><span class="spaces">    </span><span class="istickedoff">let arrBounds = ((0,0,0), (fromIntegral h-1, fromIntegral w-1, 3))</span>
<span class="lineno"> 1035 </span><span class="spaces">    </span><span class="istickedoff">arr &lt;- (newArray_ arrBounds) :: IO (StorableArray (Int,Int,Int) Word8)</span>
<span class="lineno"> 1036 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1037 </span><span class="spaces">    </span><span class="istickedoff">-- Have OpenGL fill the array with the texture data and then write out that data to an image file using DevIL</span>
<span class="lineno"> 1038 </span><span class="spaces">    </span><span class="istickedoff">withStorableArray arr $ \ptr2 -&gt; do</span>
<span class="lineno"> 1039 </span><span class="spaces">        </span><span class="istickedoff">glGetTexImage gl_TEXTURE_2D 0 gl_RGBA gl_UNSIGNED_BYTE (castPtr ptr2)</span>
<span class="lineno"> 1040 </span><span class="spaces">        </span><span class="istickedoff">writeImageFromPtr savePath (fromIntegral h, fromIntegral w) (castPtr ptr2)</span>
<span class="lineno"> 1041 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1042 </span><span class="spaces">    </span><span class="istickedoff">-- Unbind this texture so it isn't the one being used anymore</span>
<span class="lineno"> 1043 </span><span class="spaces">    </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno"> 1044 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1045 </span><span class="spaces">    </span><span class="istickedoff">-- Delete the texture since it won't be needed anymore</span>
<span class="lineno"> 1046 </span><span class="spaces">    </span><span class="istickedoff">glDeleteTextures 1 texIdPtr2</span>
<span class="lineno"> 1047 </span><span class="spaces">    </span><span class="istickedoff">free texIdPtr2</span></span>
<span class="lineno"> 1048 </span>
<span class="lineno"> 1049 </span>
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>
<span class="lineno"> 1052 </span>
<span class="lineno"> 1053 </span>
<span class="lineno"> 1054 </span>-- Function to delete a specified board/buffer from memory
<span class="lineno"> 1055 </span>--   * b - The name of the buffer (board) object to be deleted
<span class="lineno"> 1056 </span>deleteBuffer :: CBenv -&gt; BufferId -&gt; IO ()
<span class="lineno"> 1057 </span><span class="decl"><span class="istickedoff">deleteBuffer env b = do</span>
<span class="lineno"> 1058 </span><span class="spaces">    </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="istickedoff">fragMap &lt;- get (fracFunctionInfo env)</span>
<span class="lineno"> 1060 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1061 </span><span class="spaces">    </span><span class="istickedoff">-- Check to make sure the board being deleted exists</span>
<span class="lineno"> 1062 </span><span class="spaces">    </span><span class="istickedoff">if member b texMap then do</span>
<span class="lineno"> 1063 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1064 </span><span class="spaces">        </span><span class="istickedoff">-- Look up the board we need to delete</span>
<span class="lineno"> 1065 </span><span class="spaces">        </span><span class="istickedoff">let (Just texInfo) = lookup b texMap</span>
<span class="lineno"> 1066 </span><span class="spaces">            </span><span class="istickedoff">texIdPtr = texPtr texInfo</span>
<span class="lineno"> 1067 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1068 </span><span class="spaces">        </span><span class="istickedoff">-- Delete the texture</span>
<span class="lineno"> 1069 </span><span class="spaces">        </span><span class="istickedoff">glDeleteTextures 1 texIdPtr</span>
<span class="lineno"> 1070 </span><span class="spaces">        </span><span class="istickedoff">free texIdPtr</span>
<span class="lineno"> 1071 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1072 </span><span class="spaces">        </span><span class="istickedoff">-- This deletes the mapping</span>
<span class="lineno"> 1073 </span><span class="spaces">        </span><span class="istickedoff">setTexMap env (delete b texMap)</span>
<span class="lineno"> 1074 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1075 </span><span class="spaces">      </span><span class="istickedoff">else if <span class="tickonlytrue">member b fragMap</span> then do</span>
<span class="lineno"> 1076 </span><span class="spaces">        </span><span class="istickedoff">--return ()</span>
<span class="lineno"> 1077 </span><span class="spaces">        </span><span class="istickedoff">let (Just fragInfo) = lookup b fragMap</span>
<span class="lineno"> 1078 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1079 </span><span class="spaces">        </span><span class="istickedoff">deleteObjectNames [ffProg fragInfo]</span>
<span class="lineno"> 1080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1081 </span><span class="spaces">        </span><span class="istickedoff">fracFunctionInfo env $~ delete b</span>
<span class="lineno"> 1082 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1083 </span><span class="spaces">      </span><span class="istickedoff">else <span class="nottickedoff">do </span></span>
<span class="lineno"> 1084 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">print (&quot;Error: The board/function to be deleted doesn't exist: &quot; ++ show b)</span></span>
<span class="lineno"> 1085 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span></span>
<span class="lineno"> 1086 </span>
<span class="lineno"> 1087 </span>
<span class="lineno"> 1088 </span>
<span class="lineno"> 1089 </span>
<span class="lineno"> 1090 </span>
<span class="lineno"> 1091 </span>openStream :: CBenv -&gt; StreamId -&gt; String -&gt; Bool -&gt; IO ()
<span class="lineno"> 1092 </span><span class="decl"><span class="istickedoff">openStream env streamID cmd verb = do</span>
<span class="lineno"> 1093 </span><span class="spaces">        </span><span class="istickedoff">outpipe &lt;- openVideoOutPipe verb cmd</span>
<span class="lineno"> 1094 </span><span class="spaces">        </span><span class="istickedoff">addOutStream env streamID outpipe</span></span>
<span class="lineno"> 1095 </span>--        writeIORef (currentStream env) (Just streamID)
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>
<span class="lineno"> 1098 </span>closeStream :: CBenv -&gt; StreamId -&gt; IO ()
<span class="lineno"> 1099 </span><span class="decl"><span class="istickedoff">closeStream env streamID = do</span>
<span class="lineno"> 1100 </span><span class="spaces">        </span><span class="istickedoff">stream &lt;- getOutStream env streamID</span>
<span class="lineno"> 1101 </span><span class="spaces">        </span><span class="istickedoff">closeVideoOutPipe stream</span>
<span class="lineno"> 1102 </span><span class="spaces">        </span><span class="istickedoff">rmOutStream env streamID</span></span>
<span class="lineno"> 1103 </span>--        writeIORef (currentStream env) (Nothing)
<span class="lineno"> 1104 </span>
<span class="lineno"> 1105 </span>
<span class="lineno"> 1106 </span>writeStream :: CBenv -&gt; BufferId -&gt; StreamId -&gt; IO ()
<span class="lineno"> 1107 </span><span class="decl"><span class="istickedoff">writeStream env b streamID = do</span>
<span class="lineno"> 1108 </span><span class="spaces">        </span><span class="istickedoff">outpipe &lt;- getOutStream env streamID</span>
<span class="lineno"> 1109 </span><span class="spaces">        </span><span class="istickedoff">fboSupp &lt;- getFBOSupport env</span>
<span class="lineno"> 1110 </span><span class="spaces">        </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno"> 1111 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1112 </span><span class="spaces">        </span><span class="istickedoff">-- Check to make sure the board being saved exists</span>
<span class="lineno"> 1113 </span><span class="spaces">        </span><span class="istickedoff">when (notMember b texMap) $ <span class="nottickedoff">do</span></span>
<span class="lineno"> 1114 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">print &quot;Error: The board to be saved doesn't exist.&quot;</span></span>
<span class="lineno"> 1115 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">exitWith (ExitFailure 1)</span></span>
<span class="lineno"> 1116 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1117 </span><span class="spaces">        </span><span class="istickedoff">-- Look up the board we need to save</span>
<span class="lineno"> 1118 </span><span class="spaces">        </span><span class="istickedoff">let (Just texInfo) = lookup b texMap</span>
<span class="lineno"> 1119 </span><span class="spaces">            </span><span class="istickedoff">texIdPtr = texPtr texInfo</span>
<span class="lineno"> 1120 </span><span class="spaces">            </span><span class="istickedoff">(w,h) = texSize texInfo</span>
<span class="lineno"> 1121 </span><span class="spaces">            </span><span class="istickedoff">colorType = gl_RGB</span>
<span class="lineno"> 1122 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1123 </span><span class="spaces">        </span><span class="istickedoff">texId &lt;- peek texIdPtr</span>
<span class="lineno"> 1124 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1125 </span><span class="spaces">        </span><span class="istickedoff">-- Create and bind a new texture object to use as the RGBA texture for outputting</span>
<span class="lineno"> 1126 </span><span class="spaces">        </span><span class="istickedoff">texIdPtr2 &lt;- malloc :: IO(Ptr GLuint)</span>
<span class="lineno"> 1127 </span><span class="spaces">        </span><span class="istickedoff">glGenTextures 1 texIdPtr2</span>
<span class="lineno"> 1128 </span><span class="spaces">        </span><span class="istickedoff">texId2 &lt;- peek texIdPtr2</span>
<span class="lineno"> 1129 </span><span class="spaces">        </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId2</span>
<span class="lineno"> 1130 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1131 </span><span class="spaces">        </span><span class="istickedoff">--Set up the texture object and its parameters</span>
<span class="lineno"> 1132 </span><span class="spaces">        </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MAG_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno"> 1133 </span><span class="spaces">        </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR</span>
<span class="lineno"> 1134 </span><span class="spaces">        </span><span class="istickedoff">--glTexParameteri gl_TEXTURE_2D gl_TEXTURE_MIN_FILTER $ fromIntegral gl_LINEAR_MIPMAP_LINEAR</span>
<span class="lineno"> 1135 </span><span class="spaces">        </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_S $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno"> 1136 </span><span class="spaces">        </span><span class="istickedoff">glTexParameteri gl_TEXTURE_2D gl_TEXTURE_WRAP_T $ fromIntegral gl_CLAMP_TO_EDGE</span>
<span class="lineno"> 1137 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1138 </span><span class="spaces">        </span><span class="istickedoff">when (fboSupp) $ do</span>
<span class="lineno"> 1139 </span><span class="spaces">                </span><span class="istickedoff">-- Create the new texture object so that we can draw directly into it</span>
<span class="lineno"> 1140 </span><span class="spaces">                </span><span class="istickedoff">glTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) (fromIntegral w) (fromIntegral h) 0 colorType gl_UNSIGNED_BYTE nullPtr</span>
<span class="lineno"> 1141 </span><span class="spaces">                </span><span class="istickedoff">-- Attach the new texture to a FBO color attachment point</span>
<span class="lineno"> 1142 </span><span class="spaces">                </span><span class="istickedoff">bindFrameBufferToTexture <span class="nottickedoff">env</span> texId2 (Left (w,h))</span>
<span class="lineno"> 1143 </span><span class="spaces">                </span><span class="istickedoff">-- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texId2 0</span>
<span class="lineno"> 1144 </span><span class="spaces">                </span><span class="istickedoff"></span>
<span class="lineno"> 1145 </span><span class="spaces">        </span><span class="istickedoff">-- Bind the original (non-RGBA) texture so that it can be copied into the new one</span>
<span class="lineno"> 1146 </span><span class="spaces">        </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId</span>
<span class="lineno"> 1147 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1148 </span><span class="spaces">        </span><span class="istickedoff">clear [ColorBuffer, DepthBuffer] -- clear the screen and the depth buffer</span>
<span class="lineno"> 1149 </span><span class="spaces">        </span><span class="istickedoff">loadIdentity -- reset view</span>
<span class="lineno"> 1150 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1151 </span><span class="spaces">        </span><span class="istickedoff">color (Color4 1 1 1 (1::GL.GLfloat))</span>
<span class="lineno"> 1152 </span><span class="spaces">        </span><span class="istickedoff">-- Render the final board we want to save to file</span>
<span class="lineno"> 1153 </span><span class="spaces">        </span><span class="istickedoff">renderPrimitive Quads $ do</span>
<span class="lineno"> 1154 </span><span class="spaces">            </span><span class="istickedoff">texCoord (TexCoord2 0 (1::GL.GLfloat)) -- Bottom Left</span>
<span class="lineno"> 1155 </span><span class="spaces">            </span><span class="istickedoff">vertex (Vertex3 0 0 (0::GL.GLfloat)) -- Used to be GL.GLsizei, does it matter?</span>
<span class="lineno"> 1156 </span><span class="spaces">            </span><span class="istickedoff">texCoord (TexCoord2 1 (1::GL.GLfloat)) -- Bottom Right</span>
<span class="lineno"> 1157 </span><span class="spaces">            </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w) 0 (0::GL.GLfloat))</span>
<span class="lineno"> 1158 </span><span class="spaces">            </span><span class="istickedoff">texCoord (TexCoord2 1 (0::GL.GLfloat)) -- Top Right</span>
<span class="lineno"> 1159 </span><span class="spaces">            </span><span class="istickedoff">vertex (Vertex3 (fromIntegral w) (fromIntegral h) (0::GL.GLfloat))</span>
<span class="lineno"> 1160 </span><span class="spaces">            </span><span class="istickedoff">texCoord (TexCoord2 0 (0::GL.GLfloat)) -- Top Left</span>
<span class="lineno"> 1161 </span><span class="spaces">            </span><span class="istickedoff">vertex (Vertex3 0 (fromIntegral h) (0::GL.GLfloat))</span>
<span class="lineno"> 1162 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1163 </span><span class="spaces">        </span><span class="istickedoff">-- Bind the new texture again so that it can be saved</span>
<span class="lineno"> 1164 </span><span class="spaces">        </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texId2</span>
<span class="lineno"> 1165 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1166 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlytrue">(fboSupp)</span></span>
<span class="lineno"> 1167 </span><span class="spaces">            </span><span class="istickedoff">then do</span>
<span class="lineno"> 1168 </span><span class="spaces">                </span><span class="istickedoff">-- Unattach the new texture from the FBO color attachment point since it will be deleted</span>
<span class="lineno"> 1169 </span><span class="spaces">                </span><span class="istickedoff">cbBrd &lt;- getCurrentBoard env</span>
<span class="lineno"> 1170 </span><span class="spaces">                </span><span class="istickedoff">bindFrameBufferToTexture env 0 (Right cbBrd)</span>
<span class="lineno"> 1171 </span><span class="spaces">            </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno"> 1172 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">-- Copy the texture from the screen to the new texture for saving</span></span>
<span class="lineno"> 1173 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">glCopyTexImage2D gl_TEXTURE_2D 0 (fromIntegral colorType) 0 0 (fromIntegral w) (fromIntegral h) 0</span>   </span>
<span class="lineno"> 1174 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1175 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1176 </span><span class="spaces">        </span><span class="istickedoff">-- Create a new array with the image data so that we can write it out with devIL</span>
<span class="lineno"> 1177 </span><span class="spaces">        </span><span class="istickedoff">let arrBounds = ((0,0,0), (fromIntegral h-1, fromIntegral w-1, 2))</span>
<span class="lineno"> 1178 </span><span class="spaces">        </span><span class="istickedoff">arr &lt;- (newArray_ arrBounds) :: IO (StorableArray (Int,Int,Int) Word8)</span>
<span class="lineno"> 1179 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1180 </span><span class="spaces">        </span><span class="istickedoff">-- Have OpenGL fill the array with the texture data and then write out that data to an image file using DevIL</span>
<span class="lineno"> 1181 </span><span class="spaces">        </span><span class="istickedoff">withStorableArray arr $ \ptr2 -&gt; do</span>
<span class="lineno"> 1182 </span><span class="spaces">            </span><span class="istickedoff">glGetTexImage gl_TEXTURE_2D 0 colorType gl_UNSIGNED_BYTE (castPtr ptr2)</span>
<span class="lineno"> 1183 </span><span class="spaces">            </span><span class="istickedoff">writeNextFrame outpipe (fromIntegral w, fromIntegral h) (castPtr ptr2)</span>
<span class="lineno"> 1184 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1185 </span><span class="spaces">        </span><span class="istickedoff">-- Unbind this texture so it isn't the one being used anymore</span>
<span class="lineno"> 1186 </span><span class="spaces">        </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span>
<span class="lineno"> 1187 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1188 </span><span class="spaces">        </span><span class="istickedoff">-- Delete the texture since it won't be needed anymore</span>
<span class="lineno"> 1189 </span><span class="spaces">        </span><span class="istickedoff">glDeleteTextures 1 texIdPtr2</span>
<span class="lineno"> 1190 </span><span class="spaces">        </span><span class="istickedoff">free texIdPtr2</span></span>        
<span class="lineno"> 1191 </span>
<span class="lineno"> 1192 </span>
<span class="lineno"> 1193 </span>
<span class="lineno"> 1194 </span>
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>
<span class="lineno"> 1197 </span>
<span class="lineno"> 1198 </span>
<span class="lineno"> 1199 </span>allocFragmentShader :: CBenv -&gt; FragFunctionId -&gt; String -&gt; [String] -&gt; IO ()
<span class="lineno"> 1200 </span><span class="decl"><span class="istickedoff">allocFragmentShader env f txt args = do</span>
<span class="lineno"> 1201 </span><span class="spaces">        </span><span class="istickedoff">[shader] &lt;- genObjectNames 1</span>
<span class="lineno"> 1202 </span><span class="spaces"></span><span class="istickedoff">--      let types_ = (shader :: FragmentShader)</span>
<span class="lineno"> 1203 </span><span class="spaces">        </span><span class="istickedoff">shaderSource shader $= [txt]</span>
<span class="lineno"> 1204 </span><span class="spaces">        </span><span class="istickedoff">compileShader shader</span>
<span class="lineno"> 1205 </span><span class="spaces">        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1206 </span><span class="spaces">        </span><span class="istickedoff">ok &lt;- get $ compileStatus shader</span>
<span class="lineno"> 1207 </span><span class="spaces">        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1208 </span><span class="spaces">        </span><span class="istickedoff">when (not ok) $ <span class="nottickedoff">do </span></span>
<span class="lineno"> 1209 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">putStrLn $ txt</span></span>
<span class="lineno"> 1210 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">infoLog &lt;- get (shaderInfoLog shader)</span></span>
<span class="lineno"> 1211 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">putStrLn infoLog</span></span>
<span class="lineno"> 1212 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">error (&quot;Compilation failed &quot; ++ show (f,txt))</span></span>
<span class="lineno"> 1213 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1214 </span><span class="spaces">        </span><span class="istickedoff">[brickProg] &lt;- genObjectNames 1</span>
<span class="lineno"> 1215 </span><span class="spaces">        </span><span class="istickedoff">attachedShaders brickProg $= ([], [shader])</span>
<span class="lineno"> 1216 </span><span class="spaces">        </span><span class="istickedoff">linkProgram brickProg</span>
<span class="lineno"> 1217 </span><span class="spaces">        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1218 </span><span class="spaces">        </span><span class="istickedoff">ok' &lt;- get (linkStatus brickProg)</span>
<span class="lineno"> 1219 </span><span class="spaces"></span><span class="istickedoff">--        infoLog &lt;- get (programInfoLog brickProg)</span>
<span class="lineno"> 1220 </span><span class="spaces"></span><span class="istickedoff">--        mapM_ putStrLn [&quot;Program info log:&quot;, infoLog, &quot;&quot;]</span>
<span class="lineno"> 1221 </span><span class="spaces">        </span><span class="istickedoff">when (not ok') $ <span class="nottickedoff">do</span></span>
<span class="lineno"> 1222 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">deleteObjectNames [brickProg]</span></span>
<span class="lineno"> 1223 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">ioError (userError &quot;linking failed&quot;)</span></span>
<span class="lineno"> 1224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1225 </span><span class="spaces">        </span><span class="istickedoff">-- not not need the shader code *after* we have linked the program (I think!)</span>
<span class="lineno"> 1226 </span><span class="spaces">        </span><span class="istickedoff">deleteObjectNames [shader]</span>
<span class="lineno"> 1227 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1228 </span><span class="spaces">        </span><span class="istickedoff">fracFunctionInfo env $~ insert f (FragFunctionInfo <span class="nottickedoff">args</span> brickProg)</span>
<span class="lineno"> 1229 </span><span class="spaces">        </span><span class="istickedoff"></span>
<span class="lineno"> 1230 </span><span class="spaces">        </span><span class="istickedoff">return <span class="nottickedoff">()</span></span></span>
<span class="lineno"> 1231 </span>
<span class="lineno"> 1232 </span>
<span class="lineno"> 1233 </span>splatWithFunction :: CBenv -&gt; FragFunctionId -&gt; [(String, BufferId)] -&gt; [(String, CBI.UniformArgument)] -&gt; BufferId -&gt; [UIPoint] -&gt; IO ()
<span class="lineno"> 1234 </span><span class="decl"><span class="istickedoff">splatWithFunction env fnId args  uargs bDest ptList = do</span>
<span class="lineno"> 1235 </span><span class="spaces">        </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno"> 1236 </span><span class="spaces">        </span><span class="istickedoff">mp &lt;- get (fracFunctionInfo env)</span>
<span class="lineno"> 1237 </span><span class="spaces">        </span><span class="istickedoff">case lookup fnId mp of</span>
<span class="lineno"> 1238 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;can not find function # &quot; ++ show fnId</span></span>
<span class="lineno"> 1239 </span><span class="spaces">           </span><span class="istickedoff">Just ffi -&gt; do</span>
<span class="lineno"> 1240 </span><span class="spaces">                </span><span class="istickedoff">currentProgram $= Just (ffProg ffi)</span>
<span class="lineno"> 1241 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1242 </span><span class="spaces">                </span><span class="istickedoff">let badLocation _ = False -- show loc == &quot;UniformLocation (-1)&quot;</span>
<span class="lineno"> 1243 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1244 </span><span class="spaces"></span><span class="istickedoff">{-</span>
<span class="lineno"> 1245 </span><span class="spaces">                </span><span class="istickedoff">xx &lt;- get (activeUniforms $ ffProg ffi)</span>
<span class="lineno"> 1246 </span><span class="spaces">                </span><span class="istickedoff">print xx</span>
<span class="lineno"> 1247 </span><span class="spaces"></span><span class="istickedoff">-}</span>
<span class="lineno"> 1248 </span><span class="spaces">                </span><span class="istickedoff">sequence </span>
<span class="lineno"> 1249 </span><span class="spaces">                   </span><span class="istickedoff">[ do texInfo &lt;- case lookup bSrc texMap  of</span>
<span class="lineno"> 1250 </span><span class="spaces">                                   </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot; oops: can not find src buffer &quot;</span></span>
<span class="lineno"> 1251 </span><span class="spaces">                                   </span><span class="istickedoff">Just b -&gt; return b </span>
<span class="lineno"> 1252 </span><span class="spaces">                        </span><span class="istickedoff">texIdS &lt;- peek (texPtr texInfo)</span>
<span class="lineno"> 1253 </span><span class="spaces">                        </span><span class="istickedoff">glActiveTexture (gl_TEXTURE0 + i)</span>
<span class="lineno"> 1254 </span><span class="spaces">                        </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texIdS</span>
<span class="lineno"> 1255 </span><span class="spaces">                        </span><span class="istickedoff">location &lt;- get (uniformLocation (ffProg ffi) s)</span>
<span class="lineno"> 1256 </span><span class="spaces">                        </span><span class="istickedoff">if <span class="tickonlyfalse">(badLocation <span class="nottickedoff">location</span>)</span> then  <span class="nottickedoff">error $ &quot;opps: bad location for :&quot; ++ show s</span></span>
<span class="lineno"> 1257 </span><span class="spaces">                                </span><span class="istickedoff">else uniform location $= (Index1 (fromIntegral i :: GLint))</span>
<span class="lineno"> 1258 </span><span class="spaces">                        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1259 </span><span class="spaces">                   </span><span class="istickedoff">| ((s,bSrc),i) &lt;- zip args [1..]</span>
<span class="lineno"> 1260 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno"> 1261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1263 </span><span class="spaces">                </span><span class="istickedoff">sequence </span>
<span class="lineno"> 1264 </span><span class="spaces">                   </span><span class="istickedoff">[ do       location &lt;- get (uniformLocation (ffProg ffi) s)</span>
<span class="lineno"> 1265 </span><span class="spaces">                        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1266 </span><span class="spaces">                        </span><span class="istickedoff">if <span class="tickonlyfalse">(badLocation <span class="nottickedoff">location</span>)</span> </span>
<span class="lineno"> 1267 </span><span class="spaces">                                        </span><span class="istickedoff">then  <span class="nottickedoff">error $ &quot;opps: bad location for :&quot; ++ show s</span></span>
<span class="lineno"> 1268 </span><span class="spaces">                                </span><span class="istickedoff">else return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1269 </span><span class="spaces">                        </span><span class="istickedoff">case arg of</span>
<span class="lineno"> 1270 </span><span class="spaces">                           </span><span class="istickedoff">CBI.Vec2 (x,y) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1271 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">uniform location $= (Vertex2 (floatToGLclampf x) (floatToGLclampf y))</span></span>
<span class="lineno"> 1272 </span><span class="spaces">                           </span><span class="istickedoff">CBI.Vec3 (x,y,z) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1273 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">uniform location $= (Vertex3 (floatToGLclampf x) (floatToGLclampf y) (floatToGLclampf z))</span></span>
<span class="lineno"> 1274 </span><span class="spaces">                           </span><span class="istickedoff">CBI.Vec4 (x,y,z,t) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1275 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">uniform location $= (Vertex4 (floatToGLclampf x) (floatToGLclampf y) (floatToGLclampf z) (floatToGLclampf t))</span></span>
<span class="lineno"> 1276 </span><span class="spaces">                           </span><span class="istickedoff">CBI.ArrVec2 vecs -&gt; do</span>
<span class="lineno"> 1277 </span><span class="spaces">                                </span><span class="istickedoff">withArray [ Vertex2 (realToFrac x) (realToFrac y) :: Vertex2 GLfloat</span>
<span class="lineno"> 1278 </span><span class="spaces">                                          </span><span class="istickedoff">| (x,y) &lt;- vecs </span>
<span class="lineno"> 1279 </span><span class="spaces">                                          </span><span class="istickedoff">] $ \ ptr -&gt; uniformv location (fromIntegral $ length vecs) ptr</span>
<span class="lineno"> 1280 </span><span class="spaces">                           </span><span class="istickedoff">CBI.Float f -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1281 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">uniform location $= (Index1 (floatToGLfloat f))</span></span>
<span class="lineno"> 1282 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1283 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1284 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1285 </span><span class="spaces">                           </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;Opps: &quot; ++ show (s,arg)</span></span>
<span class="lineno"> 1286 </span><span class="spaces">                        </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1287 </span><span class="spaces">                   </span><span class="istickedoff">| (s,CBI.UniformArgument arg) &lt;- uargs</span>
<span class="lineno"> 1288 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno"> 1289 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1290 </span><span class="spaces"></span><span class="istickedoff">{-</span>
<span class="lineno"> 1291 </span><span class="spaces">                </span><span class="istickedoff">srcTexInfo1 &lt;- case lookup bSrc1 texMap  of</span>
<span class="lineno"> 1292 </span><span class="spaces">                                </span><span class="istickedoff">Nothing -&gt; error $ &quot; oops: can not find src buffer &quot;</span>
<span class="lineno"> 1293 </span><span class="spaces">                                </span><span class="istickedoff">Just i -&gt; return i </span>
<span class="lineno"> 1294 </span><span class="spaces">                </span><span class="istickedoff">srcTexInfo2 &lt;- case lookup bSrc2 texMap  of</span>
<span class="lineno"> 1295 </span><span class="spaces">                                </span><span class="istickedoff">Nothing -&gt; error $ &quot; oops: can not find src buffer &quot;</span>
<span class="lineno"> 1296 </span><span class="spaces">                                </span><span class="istickedoff">Just i -&gt; return i </span>
<span class="lineno"> 1297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1298 </span><span class="spaces">                </span><span class="istickedoff">-- we are assuming that we are using texture location 0 here</span>
<span class="lineno"> 1299 </span><span class="spaces">                </span><span class="istickedoff">texIdS1 &lt;- peek (texPtr srcTexInfo1)</span>
<span class="lineno"> 1300 </span><span class="spaces">                </span><span class="istickedoff">texIdS2 &lt;- peek (texPtr srcTexInfo2)</span>
<span class="lineno"> 1301 </span><span class="spaces">                </span><span class="istickedoff">glActiveTexture (gl_TEXTURE0 + 0)</span>
<span class="lineno"> 1302 </span><span class="spaces">                </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texIdS1</span>
<span class="lineno"> 1303 </span><span class="spaces">                </span><span class="istickedoff">glActiveTexture (gl_TEXTURE0 + 1)</span>
<span class="lineno"> 1304 </span><span class="spaces">                </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D texIdS2</span>
<span class="lineno"> 1305 </span><span class="spaces">                </span><span class="istickedoff">location &lt;- get (uniformLocation (ffProg ffi) s1)</span>
<span class="lineno"> 1306 </span><span class="spaces">                </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1307 </span><span class="spaces">                </span><span class="istickedoff">uniform location $= (Index1 (0 :: GLint))</span>
<span class="lineno"> 1308 </span><span class="spaces">                </span><span class="istickedoff">location &lt;- get (uniformLocation (ffProg ffi) s2)</span>
<span class="lineno"> 1309 </span><span class="spaces">                </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1310 </span><span class="spaces">                </span><span class="istickedoff">uniform location $= (Index1 (1 :: GLint))</span>
<span class="lineno"> 1311 </span><span class="spaces">                </span><span class="istickedoff">print &quot;&gt;????&quot;</span>
<span class="lineno"> 1312 </span><span class="spaces">                </span><span class="istickedoff">location &lt;- get (uniformLocation (ffProg ffi) &quot;tc_offset&quot;)</span>
<span class="lineno"> 1313 </span><span class="spaces">                </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1314 </span><span class="spaces">                </span><span class="istickedoff">withArray ([Vertex2 (x*(1/480)) (y*(1/360)) | y &lt;- [-1,0,1],x &lt;- [-1,0,1]] :: [Vertex2 GLfloat]) $ \ ptr -&gt;</span>
<span class="lineno"> 1315 </span><span class="spaces">                        </span><span class="istickedoff">uniformv location 9 ptr</span>
<span class="lineno"> 1316 </span><span class="spaces">                </span><span class="istickedoff">reportErrors</span>
<span class="lineno"> 1317 </span><span class="spaces">                </span><span class="istickedoff">print &quot;&gt;????&quot;</span>
<span class="lineno"> 1318 </span><span class="spaces"></span><span class="istickedoff">-}</span>
<span class="lineno"> 1319 </span><span class="spaces"></span><span class="istickedoff">--           splatPolygon2 env bSrc1 bDest ptMaps</span>
<span class="lineno"> 1320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1321 </span><span class="spaces">                </span><span class="istickedoff">let (Just texInfoD) = lookup bDest texMap</span>
<span class="lineno"> 1322 </span><span class="spaces">                    </span><span class="istickedoff">texIdPtrD = texPtr texInfoD</span>
<span class="lineno"> 1323 </span><span class="spaces">                    </span><span class="istickedoff">(w,h) = texSize texInfoD</span>
<span class="lineno"> 1324 </span><span class="spaces">                    </span><span class="istickedoff">--colorType = texFormat texInfoD</span>
<span class="lineno"> 1325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1326 </span><span class="spaces">                </span><span class="istickedoff">texIdD &lt;- peek texIdPtrD</span>
<span class="lineno"> 1327 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1328 </span><span class="spaces">                </span><span class="istickedoff">bindFrameBufferToTexture env texIdD (Right bDest)</span>
<span class="lineno"> 1329 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1330 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1331 </span><span class="spaces">                </span><span class="istickedoff">renderPrimitive Polygon $</span>
<span class="lineno"> 1332 </span><span class="spaces">                        </span><span class="istickedoff">placeVerticies w h [ PointMap xy xy | xy &lt;- ptList ]</span>
<span class="lineno"> 1333 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1334 </span><span class="spaces">                </span><span class="istickedoff">currentProgram $= Nothing</span>
<span class="lineno"> 1335 </span><span class="spaces">                </span><span class="istickedoff">glActiveTexture (gl_TEXTURE0 + 0)</span>
<span class="lineno"> 1336 </span><span class="spaces">                </span><span class="istickedoff">glBindTexture gl_TEXTURE_2D 0</span></span>
<span class="lineno"> 1337 </span>
<span class="lineno"> 1338 </span>{-
<span class="lineno"> 1339 </span>splatPolygon2 env bS bD ps = do
<span class="lineno"> 1340 </span>    fboSupp &lt;- getFBOSupport env
<span class="lineno"> 1341 </span>    texMap &lt;- getTexMap env
<span class="lineno"> 1342 </span>
<span class="lineno"> 1343 </span>    -- Check to make sure both the source and destination boards exist
<span class="lineno"> 1344 </span>    when (notMember bD texMap) $ do
<span class="lineno"> 1345 </span>            print &quot;Error: The destination board to splat to doesn't exist. (splatPolygon2)&quot;
<span class="lineno"> 1346 </span>            exitWith (ExitFailure 1)
<span class="lineno"> 1347 </span>    when (notMember bS texMap) $ do
<span class="lineno"> 1348 </span>            print &quot;Error: The source board to splat doesn't exist.&quot;
<span class="lineno"> 1349 </span>            exitWith (ExitFailure 1)
<span class="lineno"> 1350 </span>    
<span class="lineno"> 1351 </span>    -- Look up all of the values that will be needed
<span class="lineno"> 1352 </span>    let (Just texInfoD) = lookup bD texMap
<span class="lineno"> 1353 </span>        (Just texInfoS) = lookup bS texMap
<span class="lineno"> 1354 </span>        texIdPtrD = texPtr texInfoD
<span class="lineno"> 1355 </span>        texIdPtrS' = texPtr texInfoS
<span class="lineno"> 1356 </span>        (w,h) = texSize texInfoD
<span class="lineno"> 1357 </span>        colorType = texFormat texInfoD
<span class="lineno"> 1358 </span>    
<span class="lineno"> 1359 </span>    texIdD &lt;- peek texIdPtrD
<span class="lineno"> 1360 </span>    texIdS' &lt;- peek texIdPtrS'
<span class="lineno"> 1361 </span>    
<span class="lineno"> 1362 </span>    if False
<span class="lineno"> 1363 </span>        then return ()            
<span class="lineno"> 1364 </span>        else do
<span class="lineno"> 1365 </span>            -- Attach the texture to a FBO color attachment point
<span class="lineno"> 1366 </span>            -- glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D texIdD 0
<span class="lineno"> 1367 </span>            -- Check to see if the texture is trying to recursively draw onto itself, and if so create a copy of the source texture
<span class="lineno"> 1368 </span>            -- to prevent the undefined feedback loop that would result from drawing straight to the same texture that is being read
<span class="lineno"> 1369 </span>            (texIdS, texIdPtrS) &lt;- if (texIdD == texIdS')
<span class="lineno"> 1370 </span>                                       then fixTexLoopback texInfoS --Could call after binding texIdS' to avoid an extra binding or two maybe?
<span class="lineno"> 1371 </span>                                       else return (texIdS', texIdPtrS')
<span class="lineno"> 1372 </span>    
<span class="lineno"> 1373 </span>            -- Bind the source texture that will be splatted on    
<span class="lineno"> 1374 </span>--            glBindTexture gl_TEXTURE_2D texIdS
<span class="lineno"> 1375 </span>            --Uses relative positions (percentages) of source and destination boards
<span class="lineno"> 1376 </span>            renderPrimitive Polygon $
<span class="lineno"> 1377 </span>                placeVerticies w h ps  
<span class="lineno"> 1378 </span>
<span class="lineno"> 1379 </span>            -- If a new source texture was created to prevent a feedback loop, then delete it
<span class="lineno"> 1380 </span>--            when (texIdS /= texIdS') $ do
<span class="lineno"> 1381 </span>--                    glDeleteTextures 1 texIdPtrS
<span class="lineno"> 1382 </span>
<span class="lineno"> 1383 </span>            -- Unbind Texture until it is needed (may want to take this out depending on how we order instructions coming in)
<span class="lineno"> 1384 </span>  --          glBindTexture gl_TEXTURE_2D 0
<span class="lineno"> 1385 </span>-}
<span class="lineno"> 1386 </span>
<span class="lineno"> 1387 </span>
<span class="lineno"> 1388 </span>
<span class="lineno"> 1389 </span>
<span class="lineno"> 1390 </span>
<span class="lineno"> 1391 </span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>changeMouseCallback :: CBenv -&gt; (UIPoint -&gt; IO()) -&gt; IO ()
<span class="lineno"> 1394 </span><span class="decl"><span class="nottickedoff">changeMouseCallback env fn = do</span>
<span class="lineno"> 1395 </span><span class="spaces">        </span><span class="nottickedoff">mbChan &lt;- get (callbackChan env)</span>
<span class="lineno"> 1396 </span><span class="spaces">        </span><span class="nottickedoff"></span>
<span class="lineno"> 1397 </span><span class="spaces">        </span><span class="nottickedoff">case mbChan of</span>
<span class="lineno"> 1398 </span><span class="spaces">                </span><span class="nottickedoff">Just chan -&gt; writeChan chan (ChangeMouseFunc fn)</span>
<span class="lineno"> 1399 </span><span class="spaces">                </span><span class="nottickedoff">Nothing   -&gt; do</span>
<span class="lineno"> 1400 </span><span class="spaces">                        </span><span class="nottickedoff">chan &lt;- newChan</span>
<span class="lineno"> 1401 </span><span class="spaces">                        </span><span class="nottickedoff">(callbackChan env) $= Just chan</span>
<span class="lineno"> 1402 </span><span class="spaces">                        </span><span class="nottickedoff"></span>
<span class="lineno"> 1403 </span><span class="spaces">                        </span><span class="nottickedoff">forkIO $ callbackAssistant fn (\_ -&gt; return ()) chan</span>
<span class="lineno"> 1404 </span><span class="spaces">                        </span><span class="nottickedoff">return ()</span></span>
<span class="lineno"> 1405 </span>
<span class="lineno"> 1406 </span>
<span class="lineno"> 1407 </span>changeKeyboardCallback :: CBenv -&gt; (Char -&gt; IO()) -&gt; IO ()
<span class="lineno"> 1408 </span><span class="decl"><span class="nottickedoff">changeKeyboardCallback env fn = do</span>
<span class="lineno"> 1409 </span><span class="spaces">        </span><span class="nottickedoff">mbChan &lt;- get (callbackChan env)</span>
<span class="lineno"> 1410 </span><span class="spaces">        </span><span class="nottickedoff"></span>
<span class="lineno"> 1411 </span><span class="spaces">        </span><span class="nottickedoff">case mbChan of</span>
<span class="lineno"> 1412 </span><span class="spaces">                </span><span class="nottickedoff">Just chan -&gt; writeChan chan (ChangeKeyboardFunc fn)</span>
<span class="lineno"> 1413 </span><span class="spaces">                </span><span class="nottickedoff">Nothing   -&gt; do</span>
<span class="lineno"> 1414 </span><span class="spaces">                        </span><span class="nottickedoff">chan &lt;- newChan</span>
<span class="lineno"> 1415 </span><span class="spaces">                        </span><span class="nottickedoff">(callbackChan env) $= Just chan</span>
<span class="lineno"> 1416 </span><span class="spaces">                        </span><span class="nottickedoff"></span>
<span class="lineno"> 1417 </span><span class="spaces">                        </span><span class="nottickedoff">forkIO $ callbackAssistant (\_ -&gt; return ()) fn chan</span>
<span class="lineno"> 1418 </span><span class="spaces">                        </span><span class="nottickedoff">return ()</span></span>
<span class="lineno"> 1419 </span>
<span class="lineno"> 1420 </span>
<span class="lineno"> 1421 </span>callbackAssistant :: (UIPoint -&gt; IO ()) -&gt; (Char -&gt; IO ()) -&gt; Chan CBAcommands -&gt; IO ()
<span class="lineno"> 1422 </span><span class="decl"><span class="nottickedoff">callbackAssistant mouseFn keyFn chan = do</span>
<span class="lineno"> 1423 </span><span class="spaces">        </span><span class="nottickedoff">cmd &lt;- readChan chan</span>
<span class="lineno"> 1424 </span><span class="spaces">        </span><span class="nottickedoff">case cmd of</span>
<span class="lineno"> 1425 </span><span class="spaces">                </span><span class="nottickedoff">(MouseCallback pt)      -&gt; do</span>
<span class="lineno"> 1426 </span><span class="spaces">                                                </span><span class="nottickedoff">mouseFn pt</span>
<span class="lineno"> 1427 </span><span class="spaces">                                                </span><span class="nottickedoff">callbackAssistant mouseFn keyFn chan</span>
<span class="lineno"> 1428 </span><span class="spaces">                </span><span class="nottickedoff">(KeyboardCallback char) -&gt; do</span>
<span class="lineno"> 1429 </span><span class="spaces">                                                </span><span class="nottickedoff">keyFn char</span>
<span class="lineno"> 1430 </span><span class="spaces">                                                </span><span class="nottickedoff">callbackAssistant mouseFn keyFn chan</span>
<span class="lineno"> 1431 </span><span class="spaces">                </span><span class="nottickedoff">(ChangeMouseFunc fn)    -&gt; callbackAssistant fn keyFn chan</span>
<span class="lineno"> 1432 </span><span class="spaces">                </span><span class="nottickedoff">(ChangeKeyboardFunc fn) -&gt; callbackAssistant mouseFn fn chan</span></span>
<span class="lineno"> 1433 </span>
<span class="lineno"> 1434 </span>
<span class="lineno"> 1435 </span>
<span class="lineno"> 1436 </span>
<span class="lineno"> 1437 </span>
<span class="lineno"> 1438 </span>
<span class="lineno"> 1439 </span>
<span class="lineno"> 1440 </span>
<span class="lineno"> 1441 </span>
<span class="lineno"> 1442 </span>
<span class="lineno"> 1443 </span>-- These help with the GHC &quot;RULES&quot;, to allow fusion.
<span class="lineno"> 1444 </span>floatToGLfloat :: Float -&gt; GL.GLfloat
<span class="lineno"> 1445 </span><span class="decl"><span class="istickedoff">floatToGLfloat = realToFrac</span></span>
<span class="lineno"> 1446 </span>
<span class="lineno"> 1447 </span>floatToGLclampf :: Float -&gt; GL.GLclampf
<span class="lineno"> 1448 </span><span class="decl"><span class="istickedoff">floatToGLclampf = realToFrac</span></span>
<span class="lineno"> 1449 </span> 
<span class="lineno"> 1450 </span>
<span class="lineno"> 1451 </span>-- Should be in the CB monad, and lookup the size in a table.
<span class="lineno"> 1452 </span>bindFrameBufferToTexture :: (Integral a) =&gt; CBenv -&gt; GLuint -&gt; Either (a,a) BufferId -&gt; IO ()
<span class="lineno"> 1453 </span><span class="decl"><span class="istickedoff">bindFrameBufferToTexture env tex arg =</span>
<span class="lineno"> 1454 </span><span class="spaces">        </span><span class="istickedoff">case arg of </span>
<span class="lineno"> 1455 </span><span class="spaces">            </span><span class="istickedoff">(Left (x,y)) -&gt; bindPlease x y</span>
<span class="lineno"> 1456 </span><span class="spaces">            </span><span class="istickedoff">(Right buffId) -&gt; do</span>
<span class="lineno"> 1457 </span><span class="spaces">                </span><span class="istickedoff">texMap &lt;- getTexMap env</span>
<span class="lineno"> 1458 </span><span class="spaces">                </span><span class="istickedoff">case lookup buffId texMap of</span>
<span class="lineno"> 1459 </span><span class="spaces">                        </span><span class="istickedoff">Just texInfo -&gt; do let (x,y) = texSize texInfo</span>
<span class="lineno"> 1460 </span><span class="spaces"></span><span class="istickedoff">--                       print (buffId,tex)</span>
<span class="lineno"> 1461 </span><span class="spaces">                                           </span><span class="istickedoff">bindPlease x y </span>
<span class="lineno"> 1462 </span><span class="spaces">                        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;opps, can not find texture to bind to : &quot; ++ show tex</span></span>
<span class="lineno"> 1463 </span><span class="spaces">  </span><span class="istickedoff">where bindPlease x y = do</span>
<span class="lineno"> 1464 </span><span class="spaces">                </span><span class="istickedoff">glFramebufferTexture2D gl_FRAMEBUFFER gl_COLOR_ATTACHMENT0 gl_TEXTURE_2D tex 0</span>
<span class="lineno"> 1465 </span><span class="spaces">                </span><span class="istickedoff">viewport   $= (Position 0 0, Size (fromIntegral x) (fromIntegral y))</span>
<span class="lineno"> 1466 </span><span class="spaces">                </span><span class="istickedoff">matrixMode $= Projection</span>
<span class="lineno"> 1467 </span><span class="spaces">                </span><span class="istickedoff">loadIdentity</span>
<span class="lineno"> 1468 </span><span class="spaces">                </span><span class="istickedoff">ortho2D 0 (fromIntegral x) 0 (fromIntegral y) -- Will probably want to change this from using the window w/h</span>
<span class="lineno"> 1469 </span><span class="spaces">                </span><span class="istickedoff">matrixMode $= Modelview 0</span></span>
<span class="lineno"> 1470 </span>
<span class="lineno"> 1471 </span>
<span class="lineno"> 1472 </span>
<span class="lineno"> 1473 </span>bindFunctionToPipeline :: CBenv -&gt; Maybe FragFunctionId -&gt; IO ()
<span class="lineno"> 1474 </span><span class="decl"><span class="nottickedoff">bindFunctionToPipeline _ Nothing = do</span>
<span class="lineno"> 1475 </span><span class="spaces">        </span><span class="nottickedoff">currentProgram $= Nothing</span></span>      
<span class="lineno"> 1476 </span>        
<span class="lineno"> 1477 </span>
<span class="lineno"> 1478 </span>
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>
<span class="lineno"> 1481 </span>{-
<span class="lineno"> 1482 </span>    -- Draw a circle (or an ellipse by scaling the circle)
<span class="lineno"> 1483 </span>    -- Parameters would be xPos, yPos, rotationDegree, xScale, yScale, Color4(RGBA), radius, slices (# of points used to draw it)
<span class="lineno"> 1484 </span>    translate (Vector3 100 100 (0::GL.GLfloat)) -- Move it around to center on right position
<span class="lineno"> 1485 </span>    rotate 15 (Vector3 0 0 (-1::GL.GLfloat)) -- Rotate about -z axis so that positive degrees are clockwise
<span class="lineno"> 1486 </span>    scale 1 0.5 (1::GL.GLfloat) -- Scale the circle if it should be more of an ellipse
<span class="lineno"> 1487 </span>    color (Color4 1 0 0 (0.3::GL.GLfloat)) -- Change the color (and alpha)
<span class="lineno"> 1488 </span>    renderQuadric (QuadricStyle (Just Smooth) NoTextureCoordinates Inside FillStyle) (Disk 0 100 100 1) --inner radius, outer radius, slices, loops
<span class="lineno"> 1489 </span>--}
<span class="lineno"> 1490 </span>
<span class="lineno"> 1491 </span>
<span class="lineno"> 1492 </span>
<span class="lineno"> 1493 </span>

</pre>
</html>
